

@node Overview
@chapter Overview
@cindex Overview
The auto-overlays package automatically creates, updates and destroys
overlays based on regular expression matches in the buffer text. The
overlay is created when text is typed that matches an auto-overlay
regexp, and is destroyed if and when the matching text is changed so
that it no longer matches.

@cindex regexp sets
@cindex sets of regexps
The regexps are grouped into sets, and any number of different sets of
regexps can be active in the same buffer simultaneously. Regexps in
different sets are completely independent, and each set can be activated
and deactivated independently (@pxref{Defining Regexps}). This allows
different Emacs modes to simultaneously make use of auto-overlays in the
same buffer.

@cindex overlay classes
@cindex classes of overlay
@cindex compound overlay classes
@cindex overlay classes, compound
There are different ``classes'' of auto-overlay, used to define
different kinds of overlay behaviour. Some classes require a single
regexp, others require separate regexps to define the start and end of
the overlay (@pxref{Defining Regexps}). For the latter ``compound''
classes, the overlay is defined by a list of start and end regexps. At
least one of each must be defined, but multiple start and end regexps
are also allowed, any of which will start or end the overlay. If more
than one of the regexps matches overlapping regions of text, the one
that appears earlier in the list will take precedence. The predefined
regexp classes are: @code{word}, @code{line}, @code{self}, @code{nest}
and @code{flat}, but the auto-overlay package can easily be extended
with new classes.

@table @code
@item word
@cindex word overlay class
@cindex overlay class, word
@cindex class, word
These are used to define overlays that cover the text matched by the
regexp itself, so require a single regexp. An example use would be to
create overlays covering single words.

@item line
@cindex line overlay class
@cindex overlay class, line
@cindex class, line
These are used to define overlays that stretch from the text matching
the regexp to the end of the line, and require a single regexp to define
the start of the overlay. An example use would be to create overlays
covering single-line comments in programming languages such as c.

@item self
These are used to define overlays that stretch from one regexp match to
the next match for the same regexp, so naturally require a single
regexp. An example use would be to create overlays covering strings
delimited by @samp{""}.

@cindex self overlay class
@cindex overlay class, self
@cindex class, self
Note that for efficiency reasons, @code{self} overlays are @emph{not}
fully updated when a new match is found. Instead, when a modification is
subsequently made at any position in the buffer after the new match, the
overlays are updated @emph{up to} that position. The update occurs just
@emph{before} the modification is made. Therefore, the overlays at a
given buffer position will not necessarily be correct until a
modification is made at or after that position (@xref{To-Do}.)

@item nest
@cindex nest overlay class
@cindex overlay class, nest
@cindex class, nest
These are used to define overlays that start and end at different regexp
matches, and that can be nested one inside another. This is a compound
class, requiring separate start and end regexps. An example use would be
to create overlays between matching braces @samp{@{@}}.

@item flat
@cindex flat overlay class
@cindex overlay class, flat
@cindex class, flat
These are used to define overlays that start and end at different regexp
matches, but that can not be nested. Extra start matches within one of
these overlays are ignored. This is a compound class, requiring separate
start and end regexps. An example use would be to create overlays
covering multi-line comments in code, e.g. c++ block comments delimited
by @samp{/*} and @samp{*/}.
@end table

@cindex delimeter
@cindex regexp groups
@cindex grouping in regexps
By default, the entire text matching a regexp acts as the
``delimeter''. For example, a @code{word} overlay will cover all the
text matching its regexp, and a @code{nest} overlay will start at the
end of the text matching its start regexp. Sometimes it is useful to be
able to have only part of the regexp match act as the delimeter. This
can be done by grouping that part of the regexp (@pxref{Defining
Regexps}). Overlays will then start and end at the text matching the
group, instead of the text matching the entire regexp.

Overlay properties can be defined along with the regexp, and are applied
to any overlays created by a match to that regexp. Certain properties
have implications for auto-overlay behaviour.

@table @code
@item priority
@cindex priority property
@cindex overlay property, priority
This is a standard Emacs overlay property (@pxref{Overlay
Properties,,,elisp, GNU Emacs Lisp Reference Manual}), but it is also
used to determine which regexp takes precedence when more than two or
more regexps defining a compound class overlay match overlapping
text. It is also used to determine which regexp's properties take
precedence for overlays that are defined by start and end matches.

@item exclusive
@cindex exclusive property
@cindex overlay property, exclusive
Normally, different auto-overlay regexps coexist, and act completely
independently of one-another. However, if an auto-overlay has non-nil
@code{exclusive} and @code{priority} properties, regexp matches within
the overlay are ignored if they have lower priority. An example use is
in ignoring matches within comments in code.
@end table
@cindex overlay properties



@node Auto-Overlay Functions
@chapter Auto-Overlay Functions
@cindex functions
@cindex package, loading
@cindex loading the package
@cindex require
@cindex using auto-overlays

To use auto-overlays in an Elisp package, you must load the
overlay classes that you require by including lines of the form
@lisp
(require 'auto-overlay-@var{class})
@end lisp
near the beginning of your package, where @var{class} is the class
name. The standard classes are: @code{word}, @code{line}, @code{self},
@code{nest} and @code{flat} (@pxref{Overview}), though new classes can
easily be added (@pxref{Extending the Auto-Overlays Package}).

Sometimes it is useful for a package to make use of auto-overlays if any
are defined, without necessarily requiring them. To facilitate this, the
relevant functions can be loaded separately from the rest of the
auto-overlays package with the line
@lisp
(require 'auto-overlay-common)
@end lisp
This provides all the functions related to searching for overlays and
retrieving overlay properties, @xref{Searching for Overlays}. Note that
there is no need to include this line if any auto-overlay classes are
@code{require}d.

This section describes the functions that are needed in order to make
use of auto-overlays in an Elisp package. It does @emph{not} describe
functions related to extending the auto-overlays
package. @xref{Extending the Auto-Overlays Package}.

@menu
* Defining Regexps::            
* Starting and Stopping Auto-Overlays::  
* Searching for Overlays::      
@end menu



@node Defining Regexps
@section Defining Regexps
@cindex defining regexps
@cindex regexps, defining
@cindex regexps, loading and unloading
@cindex functions, defining regexps
@cindex functions, loading and unloading regexps

An auto-overlay regexp entry is defined by a list of the form:
@lisp
(@var{class} @var{regexp} &rest @var{properties})
@end lisp
@var{class} is one of the regexp classes described in the previous
section (@pxref{Overview}). @var{regexp} is a regular expression. Any
further elements in the list are cons cells with overlay property names
(symbols) in their cars and the property values in their cdrs.

If only part of the regexp should act as the delimeter
(@pxref{Overview}), @var{regexp} should instead be a cons cell:
@lisp
(@var{regexp} . @var{group})
@end lisp
where @var{regexp} is a regexp that contains at least one group
(@pxref{Regular Expressions,,,elisp, GNU Emacs Lisp Reference Manual}),
and @var{group} is an integer identifying which group should act as the
delimeter.

If the overlay class requires additional groups to be specified, it
@var{regexp} should instead be a list:
@lisp
(@var{regexp} @var{group0} @var{group1} ...)
@end lisp
The first @var{group0} still specifies the part that acts as the
delimeter, as before. If the entire regexp should act as the delimeter,
@var{group0} must still be supplied but should be set to 0 (meaning the
entire regexp). None of the standard classes make use of any additional
groups, but extensions to the auto-overlays package that define new
classes may. @xref{Extending the Auto-Overlays Package}.


The following functions are used to load and unload regexp definitions.
@cindex defining regexps
@cindex regexps, defining
@cindex regexps, loading and unloading
@cindex functions, defining regexps
@cindex functions, loading and unloading regexps

@table @code
@item (auto-overlay-load-regexp @var{entry} @var{set-id} &optional @var{pos} @var{entry-id})
@findex auto-overlay-load-regexp
@cindex defining regexps
@cindex regexps, defining
@cindex regexps, loading
Load an auto-overlay regexp defined by @var{entry}, which should be a
list of the form described above. @var{set-id} is a symbol identifying a
set of auto-overlay regexps. The optional parameter @var{pos} determines
where in the set's regexp list the new regexp is inserted. If it is
@code{nil}, the regexp is added at the end. If it is @code{t}, the
regexp is added at the beginning. If it is an integer, the regexp is
added at that position in the list. Whilst the position in the list has
no effect on overlay behaviour, it does determine the order in which
regexps are checked, so can affect efficiency. The optional
@var{entry-id} is a symbol that can be used to identify the regexp
later.

@cindex compound regexp
@cindex defining compound regexps
@cindex regexps, defining compound
To define a compound overlay, @command{auto-overlay-load-regexp} must
first be called with @var{entry} being a list containing just the
overlay class, e.g. @code{('nest)}, and an @var{entry-id} must be
supplied. @command{auto-overlay-load-compound-regexp} can then be called
to actually load the start and end regexp definitions themselves.


@item (auto-overlay-load-compound-regexp @var{entry} @var{set-id} @var{entry-id} &optional @var{pos} @var{subentry-id})
@findex auto-overlay-load-compound-regexp
@cindex compound regexp
@cindex defining compound regexps
@cindex loading compound regexps
@cindex regexps, defining compound
@cindex regexps, loading compound
Load a start or end regexp into the list defining a compound
regexp. @command{auto-overlay-load-regexp} must first be called as
described above. @var{entry} is the regexp definition, but the first
element of the list should be one of the symbols @code{start} or
@code{end}, rather than the overlay class. @var{set-id} is a symbol
identifying the auto-overlay regexp set as before, and @var{entry-id} is
the symbol that was supplied to the @command{auto-overlay-load-regexp}
call. The optional @var{pos} determines the position of the regexp, as
for @command{auto-overlay-load-regexp}, but this time it is the position
in the list of regexps defining the compound overlay, which can be
significant for overlay behaviour since it determines which regexp takes
precedence when two match the same text. The optional @var{subentry-id}
is a symbol that can be used to identify the regexp later.


@item (auto-overlay-unload-regexp @var{set-id} &optional @var{entry-id} @var{subentry-id})
@findex auto-overlay-unload-regexp
@cindex unloading regexps
@cindex regexps, unloading
Unload one or more regexp definitions. @var{set-id}, @var{entry-id} and
@var{subentry-id} are symbols identifying the regexp to unload, and
correspond to those supplied when loading the regexp using
@command{auto-overlay-load-regexp} and
@command{auto-overlay-load-compound-regexp}. @var{subentry-id} only
needs to be supplied if unloading a start or end regexp from a compound
class, and should be @code{nil} otherwise. Note that if @var{entry-id}
is the symbol identifying a compound class regexp, and @var{subentry-id}
is @emph{not} supplied, the entire list of start and end regexps will be
unloaded. To unload an entire set of regexp definitions, simply specify
@var{set-id} but leave @var{entry-id} and @var{subentry-id} null.


@item (auto-overlay-share-regexp-set @var{set-id} @var{from-buffer} @@optional @var{to-buffer})
@findex auto-overlay-share-regexp-set
@cindex sharing regexp sets
@cindex regexp sets, sharing between buffers
@cindex buffers, sharing regexp sets between
Share the set of regexp definitions identified by the symbol
@var{set-id} in buffer @code{from-buffer} with the buffer
@var{to-buffer}, or the current buffer if @var{to-buffer} is null. The
regexp set becomes common to both buffers, and any changes made to it in
one buffer, such as loading and unloading regexp definitions, are also
reflected in the other buffer. However, the regexp set can still be
enabled and disabled independently in both buffers. The same regexp set
can be shared between any number of buffers. To remove a shared regexp
set from one of the buffers, simply unload the entire set from that
buffer using @command{auto-overlay-unload-regexp}. The regexp set will
remain defined in all the other buffers it was shared with.
@end table



@node Starting and Stopping Auto-Overlays
@section Starting and Stopping Auto-Overlays
@cindex starting and stopping auto-overlays
@cindex regexp sets, starting and stopping
@cindex saving overlays
@cindex loading overlays
@cindex overlays, starting and stopping
@cindex overlays, saving and loading
@cindex functions, starting and stopping overlays
@cindex functions, loading and saving overlays
A set of regexps is not active until it has been ``started'', and can be
deactivated by ``stopping'' it. When a regexp set is activated, the
entire buffer is scanned for regexp matches, and the corresponding
overlays created. Similarly, when a set is deactivated, all the overlays
are deleted. Note that regexp definitions can be loaded and unloaded
whether the regexp set is active or inactive, and that deactivating a
regexp set does @emph{not} delete its regexp definitions.

Since scanning the whole buffer for regexp matches can take some time,
especially for large buffers, auto-overlay data can be saved to an
auxiliary file so that the overlays can be restored more quickly if the
same regexp set is subsequently re-activated. Of course, if the text in
the buffer is modified whilst the regexp set is disabled, or the regexp
definitions differ from those that were active when the overlay data was
saved, the saved data will be out of date. Auto-overlays automatically
checks if the text has been modified and, if it has, ignores the saved
data and re-scans the buffer. However, no check is made to ensure the
regexp definitions used in the buffer and saved data are consistent
(@pxref{To-Do}); the saved data will be used even if the definitions
have changed.

The usual time to save and restore overlay data is when a regexp set is
deactivated or activated. The auxilliary file name is then constructed
automatically from the buffer name and the set-id. However,
auto-overlays can also be saved and restored manually.


@table @code
@item (auto-overlay-start @var{set-id} @@optional @var{buffer} @var{ignore-save-file})
@findex auto-overlay-start
Activate the auto-overlay regexp set identified by the symbol
@var{set-id} in @var{buffer}, or the current buffer if the latter is
@code{nil}. If there is an file called
@file{auto-overlay-}@var{buffer-name}@file{-}@var{set-id} in the current
directory containing up-to-date overlay data, it will be used to restore
the auto-overlays (@var{buffer-name} is the name of the file visited by
the buffer, or the buffer name itself if there is none). Otherwise, the
entire buffer will be scanned for regexp matches. A non-nil
@var{ignore-save-file} will override this, causing the buffer to be
scanned even if the file exists.


@item (auto-overlay-stop @var{set-id} @@optional @var{buffer} @var{save})
@findex auto-overlay-stop
Deactivate the auto-overlay regexp set identified by the symbol
@var{set-id} in @var{buffer}, or the current buffer if the latter is
@code{nil}. All corresponding overlays will be deleted, but the regexp
definitions are preserved and can be reactivated later. If @var{save} is
non-nil, overlay data will be saved in an auxilliary file called
@file{auto-overlay-}@var{buffer-name}@file{-}@var{set-id} to speed up
subsequent reactivation of the regexp set in the same buffer
(@var{buffer-name} is the name of the file visited by the buffer, or the
buffer name itself if there is none).


@item (auto-overlay-save-overlays @var{set-id} @@optional @var{buffer} @var{file})
@findex auto-overlay-save-overlays
Save auto-overlay data for the regexp set identified by the symbol
@var{set-id} in @var{buffer}, or the current buffer if @code{nil}, to an
auxilliary file called @var{file}. If @var{file} is nil, the overlay
data are saved to a file called
@file{auto-overlay-}@var{buffer-name}@file{-}@var{set-id} in the current
directory (@var{buffer-name} is the name of the file visited by the
buffer, or the buffer name itself if there is none). Note that this is
the only name that will be recognized by @command{auto-overlay-start}.


@item (auto-overlay-load-overlays @var{set-id} @@optional @var{buffer} @var{file})
@findex auto-overlay-load-overlays
Load auto-overlay data for the regexp set identified by the symbol
@var{set-id} into @var{buffer}, or the current buffer if @code{nil},
from an auxilliary file called @var{file}. If @var{file} is nil, it
attempts to load the overlay data from a file called
@file{auto-overlay-}@var{buffer-name}@file{-}@var{set-id} in the current
directory (@var{buffer-name} is the name of the file visited by the
buffer, or the buffer name itself if there is none). Returns @code{t} is
the overlays were successfully loaded, @code{nil} otherwise.
@end table



@node Searching for Overlays
@section Searching for Overlays
@cindex searching for overlays
@cindex finding overlays
@cindex functions, searching for overlays
@cindex overlays, finding
@cindex overlay properties
Auto-overlays are just normal Emacs overlays, so any of the standard
Emacs functions can be used to search for overlays and retrieve overlay
properties. The auto-overlays package provides some additional
functions.

@table @code
@item (auto-overlays-at-point @@optional @var{point} @var{prop-test} @var{inactive})
@findex auto-overlays-at-point
Return a list of overlays overlapping @var{point}, or the point if
@var{point} is null. The list includes @emph{all} overlays, not just
auto-overlays (but see below). The list can be filtered to only return
overlays with properties matching criteria specified by
@var{prop-test}. This should be a list defining a property test, with
one of the following forms (or a list of such lists, if more than one
property test is required):
@lisp
(@var{function} @var{property})
(@var{function} @var{property} @var{value})
(@var{function} (@var{property1} @var{property2} ...) (@var{value1} @var{value2} ...))
@end lisp
where @var{function} is a function, @var{property} is an overlay
property name (a symbol), and @var{value} can be any value or lisp
expression. For each overlay, first the values corresponding to the
@var{property} names are retrieved from the overlay and any @var{value}s
that are lisp expressions are evaluated. Then @var{function} is called
with the property values followed by the other values as its
arguments. The test is satisfied if the result is non-nil, otherwise it
fails. Tests are evaluated in order, but only up to the first
failure. Only overlays that satisfy all property tests are returned.

All auto-overlays are given a non-nil @code{auto-overlay} property, so
to restrict the list to auto-overlays, @var{prop-test} should include
the following property test:
@lisp
('identity 'auto-overlay)
@end lisp
For efficiency reasons, the auto-overlays package sometimes leaves
overlays hanging around in the buffer even when they should have been
deleted. These are marked with a non-nil @code{inactive} property. By
default, @command{auto-overlays-at-point} ignores these. A non-nil
@var{inactive} will override this, causing inactive overlays to be
included in the returned list (assuming they pass all property tests).


@item (auto-overlays-in @var{start} @var{end} @@optional @var{prop-test} @var{within} @var{inactive})
@findex auto-overlays-in
Return a list of overlays overlapping the region between @var{start} and
@var{end}. The @var{prop-test} and @var{inactive} arguments have the
same behaviour as in @command{auto-overlays-at-point}, above. If
@var{within} is non-nil, only overlays that are entirely within the
region from @var{start} to @var{end} will be returned, not overlays that
extend outside that region.


@item (auto-overlay-highest-priority-at-point @@optional @var{point} @var{prop-test})
@findex auto-overlay-highest-priority-at-point
@cindex overlays, priority
@cindex highest priority overlay
Return the highest priority overlay at @var{point} (or the point, of
@var{point} is null). The @var{prop-test} argument has the same
behaviour as in @command{auto-overlays-at-point}, above. An overlay's
priority is determined by the value of its @code{priority} property
(@pxref{Overlay Properties,,,elisp, GNU Emacs Lisp Reference
Manual}). If two overlays have the same priority, the innermost one
takes precedence (i.e. the one that begins later in the buffer, or if
they begin at the same point the one that ends earlier; if two overlays
have the same priority and extend over the same region, there is no way
to predict which will be returned).

@item (auto-overlay-local-binding @var{symbol} @@optional @var{point})
@findex auto-overlay-local-binding
@cindex overlays, local-binding
@cindex overlay-local binding
@cindex local-binding
Return the ``overlay-local'' binding of @var{symbol} at @var{point} (or
the point if @var{point} is null), or the current local binding if there
is no overlay binding. An ``overlay-local'' binding for @var{symbol} is
the value of the overlay property called @var{symbol}. If more than one
overlay at @var{point} has a non-nil @var{symbol} property, the value
from the highest priority overlay is returned (see
@command{auto-overlay-highest-priority-at-point}, above, for an
explanation of ``highest priority'').
@end table




@node Worked Example
@chapter Worked Example
@cindex worked example
@cindex example
@cindex LaTeX
The interaction of all the different regexp definitions, overlay
properties and auto-overlay classes provided by the auto-overlay package
can be a little confusing. This section will go through an example of
how the auto-overlay regexps could be defined to create overlays for a
subset of La@TeX{}, which is complex enough to demonstrate most of the
features.

La@TeX{} is a markup language, so a La@TeX{} document combines markup
commands with normal text. Commands start with @samp{\}, and end at the
first non-word-constituent character. We want to highlight all La@TeX{}
commands in blue. Two commands that will particularly interest us are
@samp{\begin} and @samp{\end}, which begin and end a La@TeX{}
environment. The environment name is enclosed in braces:
@samp{\begin@{@var{environment-name}@}}, and we want it to be
highlighted in pink. La@TeX{} provides many environments, used to create
lists, tables, titles, etc. We will take the example of an
@samp{equation} environment, used to typeset mathematical
equations. Thus equations are enclosed by @samp{\begin@{equation@}} and
@samp{\end@{equation@}}, and we would like to highlight these equations
in yellow. Another example we will use is the @samp{$} delimiter. Pairs
of @samp{$}s delimit mathematical expressions that appear in the middle
of a paragraph of normal text (whereas @samp{equation} environments
appear on their own, slightly separated from surrounding text). Again,
we want to highlight these mathematical expressions, this time in
green. The final piece of La@TeX{} markup we will need to consider is
the @samp{%} character, which creates a comment that lasts till the end
of the line (i.e. text after the @samp{%} is ignored by the La@TeX{}
processor up to the end of the line).


@cindex word overlay class example
@cindex example, word class
@cindex overlay class, word example
@cindex class, word example
La@TeX{} commands are a good example of when to use @code{word} regular
expressions (@pxref{Overview}). The appropriate regexp definition is
loaded by

@lisp
(auto-o-load-regexp
 '(word "\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)"
        (face . (background-color . "blue")))
 'latex)
@end lisp

@noindent
We have called the regexp set @code{latex}. The @code{face} property is
a standard Emacs overlay property that sets font properties within the
overlay. @xref{Overlay Properties,,,elisp, GNU Emacs Lisp Reference
Manual}. @code{"\\\\"} is the string defining the regexp that matches a
@emph{single} @samp{\}. (Note that the @samp{\} character has a special
meaning in regular expressions, so to include a literal one it must be
escaped: @samp{\\}. However, @samp{\} also has a special meaning in lisp
strings, so both @samp{\} characters must be escaped there too, giving
@code{\\\\}.) @code{[[:alpha:]]*?} matches a sequence of zero or more
letter characters. The @code{?} ensures that it matches the
@emph{shortest} sequence of letters consistent with matching the regexp,
since we want the region to end at the first non-letter character,
matched by @code{[^[:alpha:]]}. The @code{\|} defines an alternative, to
allow the La@TeX{} command to be terminated either by a non-letter
character or by the end of the line (@code{$}). @xref{Regular
Expressions,,,elisp, GNU Emacs Lisp Reference Manual}, for more details
on Emacs regular expressions.

However, there's a small problem. We only want the blue background to
cover the characters making up a La@TeX{} command. But as we've defined
things so far, it will cover all the text matched by the regexp, which
includes the leading @samp{\} and the trailing non-letter character. To
rectify this, we need to group the part of the regexp that matches the
command (i.e. by surround it with @samp{\(} and @samp{\)}), and put the
regexp inside a cons cell containing the regexp in its @code{car} and a
number indicating which subgroup to use in its @code{cdr}:

@lisp
(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp


@cindex self overlay class example
@cindex overlay class, self example
@cindex example, self class
@cindex class, self example
The @samp{$} delimiter is an obvious example of when to use a
@code{self} regexp (@pxref{Overview}). We can update our example to
include this (note that @samp{$} also has a special meaning in regular
expressions, so it must be escaped with @samp{\} which itself must be
escaped in lisp strings):

@lisp
(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (face . (background-color . "green")))
 'latex)
@end lisp

@noindent
This won't quite work though. La@TeX{} maths commands also start with a
@samp{\} character, which will match the @code{word} regexp. For the
sake of example we want the entire equation highlighted in green,
without highlighting any La@TeX{} maths commands it contains in
blue. Since the @code{word} overlay will be within the @code{self}
overlay, the blue highlighting will take precedence. We can change this
by giving the @code{self} overlay a higher priority (any priority is
higher than a non-existent one; we use 3 here for later
convenience). For efficiency reasons, it's a good idea to put higher
priority regexp definitions before lower priority ones, so we get:

@lisp
(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp


@cindex nest overlay class example
@cindex overlay class, nest example
@cindex example, nest class
@cindex class, nest example
The @samp{\begin@{equation@}} and @samp{\end@{equation@}} commands also
enclose maths regions, which we would like to highlight in yellow. Since
the opening and closing delimiters are different in this case, we must
use @code{nest} overlays (@pxref{Overview}). Our example now looks like:

@lisp
(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp

@noindent
Notice how we've used @code{start} and @code{end} regexps to define the
compound regexp. Once again, we have had to escape the @samp{\}
characters, and increase the priority of the new regexp definition to
avoid any La@TeX{} commands within the maths region being highlighted in
blue.


@cindex line overlay class example
@cindex overlay class, line example
@cindex example, line class
@cindex class, line example
La@TeX{} comments start with @samp{%} and last till the end of the line:
a perfect demonstration of a @code{line} regexp. Here's a first attempt:

@lisp
(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)

(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)
@end lisp
@noindent
We use the standard Emacs @command{face-attribute} function to retrieve
the default background colour, which is evaluated before the regexp
definition is loaded. (This will of course go wrong if the default
background colour is subsequently changed, but it's sufficient for this
example). Let's think about this a bit. We probably don't want anything
within a comment to be highlighted at all, even if it matches one of the
other regexps. In fact, creating overlays for @samp{\begin} and
@samp{\end} commands which are within a comment could cause havoc! If
they don't occur in pairs within the commented region, they will
erroneously pair up with ones outside the comment. We need comments to
take precedence over everything else, and we need them to block other
regexp matches:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp


@cindex nest overlay class example
@cindex overlay class, nest example
@cindex example, nest class
@cindex class, nest example
We're well on our way to creating a useful setup, at least for the
La@TeX{} commands we're considering in this example. There is one last
type of overlay to create, but it is the most complicated. We want
environment names to be highlighted in pink, i.e. the region between
@samp{\begin@{} and @samp{@}}. A first attempt at this might result in:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{" (priority . 2)
         (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(end "@}" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp

@noindent
However, we'll hit a problem with this. The @samp{@}} character also
closes the @samp{\end@{} command. Since we haven't told auto-overlays
about @samp{\end@{}, every @samp{@}} that should close an @samp{\end@{}
command will instead be interpreted as the end of a @samp{\start@{}
command, probably resulting in lots of unmatched @samp{@}} characters,
creating pink splodges everywhere! Clearly, since we also want
environment names between @samp{\end@{} and @samp{@}} to be pink, we
need something more along the lines of:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{" (priority . 2)
         (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\end@{" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(end "@}" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp

@noindent
We still haven't solved the problem though. The @samp{@}} character
doesn't only close @samp{\begin@{} and @samp{\end@{} commands in
La@TeX{}. @emph{All} arguments to La@TeX{} commands are surrounded by
@samp{@{} and @samp{@}}. We could add all the commands that take
arguments, but we don't really want to bother about any other commands
(at least in this example). All we want to do is prevent predictive mode
incorrectly pairing the @samp{@}} characters used for other
commands. Instead, we can just add @samp{@{} to the list:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "@{" (priority . 2))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{" (priority . 2)
         (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\end@{" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(end "@}" (priority . 2))
 'latex 'environment)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp

@noindent
Notice how the @code{@{} and @code{@}} regexps do not define a
background colour (or indeed any other properties), so that any overlays
they create will have no effect other than making sure all @samp{@{} and
@samp{@}} characters are correctly paired.

We've made one mistake though: by putting the @code{@{} regexp at the
beginning of the compound regexp list, it will take priority over any
other regexp in the list that could match the same text. And since
@code{@{} will match whenever @code{\begin@{} or @code{\end@{} matches,
environments will never be highlighted! The @code{@{} regexp must come
@emph{after} the @code{\begin@{} and @code{\end@{} regexps, to ensure it
is only used if neither of them match (it doesn't matter whether it
appears before or after the @code{@{} regexp, since the latter will
never match the same text and neither set dictionaries). We can fix this
either by passing a @var{pos} argument to
@command{auto-overlay-load-compound-regexp} (@pxref{Defining Regexps}),
or more simply, since regexps are entered at the end of the compound
regep list by default, by moving the line defining the @code{@{} regexp
after the @code{\start@{} and @code{\end@{} regexps:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{" (priority . 2)
         (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\end@{" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "@{" (priority . 2))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(end "@}" (priority . 2))
 'latex 'environment)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp

There is one last issue. A literal @samp{@{} or @samp{@}} character can
be included in a La@TeX{} document by escaping it with @samp{\}:
@samp{\@{} and @samp{\@}}. In this situation, the characters do not
match anything and should not be treated as delimiters. We can modify
the @code{@{} and @code{@}} regexps to exclude these cases:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{" (priority . 2)
         (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\end@{" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\([^\\]\\|^\\)@{" (priority . 2))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(end "\\([^\\]\\|^\\)@}" (priority . 2))
 'latex 'environment)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp

@noindent
The new, complicated-looking regexps will only match @samp{@{} and
@samp{@}} characters if they are @emph{not} preceded by a @samp{\}
character (@pxref{Regular Expressions,,,elisp,GNU Emacs Lisp Reference
Manual}). Note that the character alternative @code{[^\]\|^} can match
any character that isn't a @samp{\} @emph{or} the start of a line. This
is required because macthes to auto-overlay regexps are not allowed to
span more than one line. If @samp{@{} or @samp{@}} appear at the
beginning of a line, there will be no character in front (the newline
character doesn't count, since it isn't on the same line), so the
@code{[^\]} will not match.

However, when it does match, the @code{@}} regexp will now match an
additional character before the @code{@}}, causing the overlay to end
one character early. (The @code{@{} regexp will also match one
additional character before the @code{@{}, but since the beginning of
the overlay starts from the @emph{end} of the @code{start} delimiter,
this poses no problem.) We need to group the part of the regexp that
should define the delimiter, i.e. the @code{@}}, by surrounding it with
@code{\(} and @code{\)}, and put the regexp in the @code{car} of a cons
cell whose @code{cdr} specifies the new subgroup (i.e. the 2nd subgroup,
since the regexp already included a group for other reasons). Our final
version looks like this:

@lisp
(auto-overlay-load-regexp
 `(line "%" (priority . 4) (exclusive . t)
        (face . (background-color
                 . ,(face-attribute 'default :background)))
 'latex)

(auto-overlay-load-regexp
 '(self "\\$" (priority . 3) (face . (background-color . "green")))
 'latex)

(auto-overlay-load-regexp '(nest) 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{" (priority . 2)
         (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\end@{" (priority . 2)
       (face . (background-color . "pink")))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(start "\\([^\\]\\|^\\)@{" (priority . 2))
 'latex 'environment)
(auto-overlay-load-compound-regexp
 '(end ("\\([^\\]\\|^\\)\\(@}\\)" . 2) (priority . 2))
 'latex 'environment)

(auto-overlay-load-regexp '(nest) 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(start "\\begin@{equation@}"  (priority . 1)
         (face . (background-color . "yellow")))
 'latex 'equation)
(auto-overlay-load-compound-regexp
 '(end "\\end@{equation@}" (priority . 1)
       (face . (background-color . "yellow")))
 'latex 'equation)

(auto-overlay-load-regexp
 '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" . 1)
        (face . (background-color . "blue")))
 'latex)
@end lisp


With these regexp definitions, La@TeX{} commands will automatically be
highlighted in blue, equation environments in yellow, inline maths
commands in green, and environment names in pink. La@TeX{} markup within
comments will be ignored. And @samp{@{} and @samp{@}} characters from
other commands will be correctly taken into account. All this is done in
``real-time''; it doesn't wait until Emacs is idle to update the
overlays. Not bad for a bundle of regexps!

Of course, this could all be done more easily using Emacs' built-in
syntax highlighting features, but the highlighting was only an example
to show the location of the overlays. The main point is that the
overlays are automatically created and kept up to date, and can be given
any properties you like and used for whatever purpose is required by
your Elisp package.




@node Extending the Auto-Overlays Package
@chapter Extending the Auto-Overlays Package
@cindex extending the auto-overlays package
@cindex adding new overlay classes
@cindex package, extending
@cindex classes, adding new
The auto-overlay package can easily be extended by adding new overlay
classes@footnote{Or rather, it is easy to integrate new overlay classes
into the package. Whether writing a new overlay class is easy or not
depends on what you're trying to do, and how good your coding skills are
;-)}. The next sections document the functions and interfaces provided
by the auto-overlays package for this purpose.

Often, a new class is a minor modification of one of the standard
classes. For example, it may work exactly like one of the standard
classes, but in addition call some function whenever an overlay is
created or destroyed. In this case, it is far better to build the new
class on top of the existing class, using functions from the
class-specific Elisp files, rather than starting from
scratch. @xref{Standard Parse and Suicide Functions}.


@menu
* Auto-Overlays in Depth::      
* Integrating New Overlay Classes::  
* Functions for Writing New Overlay Classes::  
* Auto-Overlay Hooks::          
* Auto-Overlay Modification Pseudo-Hooks::  
@end menu

@node Auto-Overlays in Depth
@section Auto-Overlays in Depth
@cindex auto-overlays in depth
@cindex package, in depth
In order to write new classes, a deeper understanding is required of how
the auto-overlay package works. In fact, two kinds of overlays are
automatically created, updated and destroyed when auto-overlays are
active: the auto-overlays themselves, and ``match'' overlays, used to
mark text that matches an auto-overlay regexp.

For overlay classes that only require one regexp to fully define an
overlay (the @code{word} and @code{line} classes are the only standard
class like this@footnote{Although the @code{self} class only requires
one regexp definition, the auto-overlays themselves require two matches
to that regexp to set the start and end of the overlay.}), the
auto-overlays are always matched with the corresponding match
overlay. For classes that require two regexp matches to define the start
and end of an overlay (all other standard classes), each edge of an
auto-overlay can be matched with the match overlay that defines where
the edge is located. There will always be at least one matched edge,
since an auto-overlay is only created when a regexp match is found, but
it is possible for the second edge to not yet be matched (for many
classes, the unmatched edge will be located at the beginning or end of
the buffer).

If a match overlay is matched with the start of an auto-overlay, the
match overlay is stored in the auto-overlay's @code{start} property. The
match overlay is also stored in the @code{start} property for
auto-overlays that only require a single match. If a match overlay is
matched with the end of an auto-overlay, the match overlay is stored in
the auto-overlay's @code{end} property. Conversely, the auto-overlay is
always stored in the match overlay's @code{parent} property@footnote{The
terminology is admittedly very poor, and is a relic of a previous
incarnation of the auto-overlays package, when it made more sense.}.

Whenever a buffer is modified, the lines containing the modifications
are searched for new regexp matches. If one is found, a new match
overlay is created covering the matching text, and then passed as an
argument to the appropriate ``parse'' function@footnote{More bad
terminology.} for its class. This deals with creating or updating the
appropriate auto-overlays. If the text within a match overlay is
modified, the match overlay checks whether the text it covers still
matches the regexp. If it no longer matches, the match overlay is passed
as an argument to the appropriate ``suicide'' function for its class,
which deals with updating or deleting its parent auto-overlay (and
possible other auto-overlays too).

To summarise, the core of the auto-overlays package deals with searching
for regexp matches, and creating or deleting the corresponding match
overlays. It then hands over the task of creating, updating or deleting
the auto-overlays themselves to class-specific functions, which
implement the correct behaviour for that class.



@node Integrating New Overlay Classes
@section Integrating New Overlay Classes
@cindex integrating new overlay classes
@cindex overlay classes, integrating new
@cindex classes, integrating new
@cindex extending, integrating new overlay classes
To add a new overlay class, all that is required is to write new
``parse'' and ``suicide'' functions, and inform the auto-overlays
package of their existence. A ``match'' function can also optionally be
defined. It is called whenever a match overlay in the class becomes
matched with the edge of an auto-overlay (@pxref{Functions for Modifying
Overlays}). The parse, suicide and match functions are conventionally
called @code{auto-o-parse-}@var{class}@code{-match},
@code{auto-o-}@var{class}@code{-suicide} and
@code{auto-o-match-}@var{class}, where @var{class} is the name of the
class, though the convention is not enforced in any way.

@table @asis
@item parse function
@cindex parse function
@cindex overlay classes, parse function
@cindex functions, parse function
@cindex integrating new classes, parse function
@findex auto-o-parse-@{class@}-match
A parse function is passed a single argument containing a match
overlay. It should return a list containing any new auto-overlays it
creates, or @code{nil} if none were created.
@lisp
@var{o-list} = (auto-o-parse-@var{class}-match @var{o-match})
@end lisp
Note that the parse function itself is responsible for calling the
@command{auto-o-update-exclusive} function if a new exclusive overlay is
created. @xref{Functions for Modifying Overlays}.

@item suicide function
@cindex suicide function
@cindex overlay classes, suicide function
@cindex functions, suicide function
@cindex integrating new classes, suicide function
@findex auto-o-@{class@}-suicide
A suicide function is passed a single argument containing a match
overlay. Its return value is ignored.
@lisp
(auto-o-@var{class}-suicide @var{o-match})
@end lisp
The text covered by the match overlay should be considered to no longer
match its regexp, although in certain cases matches are ignored for
other reasons and this may not really be the case (for example if a new,
higher-priority, exclusive overlay overlaps the match,
@pxref{Overview}).

@item match function
@cindex match function
@cindex overlay classes, match function
@cindex functions, match function
@cindex integrating new classes, match function
@findex auto-o-match-@{class@}
A match function is passed a single argument containing a match overlay
that has just been matched with an edge of an auto-overlay
(@pxref{Functions for Modifying Overlays}). Its return value is ignored.
@lisp
(auto-o-match-@var{class} @var{o-match})
@end lisp
The auto-overlay it is matched with is stored in the match overlay's
@code{parent} property.
@end table

To integrate the new class into the auto-overlays package, the parse and
suicide functions must be added to the property list of the symbol used
to refer to the new class, denoted here by @var{class}:
@lisp
(put '@var{class} 'auto-overlay-parse-function
     'auto-o-parse-@var{class}-match)
(put @var{class} 'auto-overlay-suicide-function
     'auto-o-@var{class}-suicide)
@end lisp
If the optional match function is defined, it should similarly be added
to the symbol's property list:
@lisp
(put '@var{class} 'auto-overlay-match-function
     'auto-o-match-@var{class})
@end lisp



@node Functions for Writing New Overlay Classes
@section Functions for Writing New Overlay Classes
@cindex functions, writing new overlay classes
@cindex overlay classes, functions for writing new
@cindex extending, functions
Some functions are provided by the auto-overlays package for use in new
parse and suicide functions. The functions that modify overlays carry
out tasks that require interaction with the core of the auto-overlays
package, and provide the only reliable way of carrying out those
tasks. The other functions are used to query various things about
auto-overlays and match overlays. Again, they are the only reliable
interface for this, since the internal implementation may change between
releases of the auto-overlays package.

@menu
* Standard Parse and Suicide Functions::  
* Functions for Modifying Overlays::  
* Functions for Querying Overlays::  
@end menu


@node Standard Parse and Suicide Functions
@subsection Standard Parse and Suicide Functions
@cindex standard parse and suicide functions
@cindex overlay classes, standard parse functions
@cindex overlay classes, standard suicide functions
@cindex class, standard parse functions
@cindex class, standard suicide functions
@cindex extending, standard parse functions
@cindex extending, standard suicide functions
All the standard overlay classes define their own parse and suicide
functions (none of them require a match function), which can be used to
create new ``derived'' classes based on the standard ones. This is the
easiest and most common way to create a new class. For example, the new
class may behave exactly like one of the standard classes, but perform
some additional processing whenever an overlay is created, destroyed, or
matched. The parse and suicide functions for the new class should
perform whatever additional processing is required, and call the
standard class functions to deal with creating and destroying the
overlay.

All the standard parse and suicide functions following the naming
convention (@pxref{Integrating New Overlay Classes}), where @var{class}
is the name of the overlay class (one of @code{word}, @code{line},
@code{self}, @code{nest} or @code{flat}, @pxref{Overview}):

@table @code
@item (auto-o-parse-@var{class}-match @var{o-match})
@findex auto-o-parse-@{class@}-match
Parse a new match overlay @var{o-match} whose class is @var{class}. This
will create or update auto-overlays, as appropriate for the class.

@item (auto-o-@var{class}-suicide @var{o-match})
@findex auto-o-@{class@}-suicide
Delete or update auto-overlays as appropriate for overlay class
@var{class}, due to the match overlay @var{o-match} no longer matching.
@end table



@node Functions for Modifying Overlays
@subsection Functions for Modifying Overlays
@cindex functions, modifying overlays
@cindex overlays, functions for modifying
@cindex extending, functions for modifying overlays
These functions modify auto-overlays and match overlays as necessary to
perform a particular update. They should probably @emph{always} be used
to carry out their corresponding tasks, since these tasks require
interaction with the core of the auto-overlays package.

@table @code
@item (auto-o-update-exclusive @var{set-id} @var{beg} @var{end} @var{old-priority} @var{new-priority})
@findex auto-o-update-exclusive
@cindex overlay property, exclusive
@cindex exclusive property
@cindex extending, updating exclusive
@cindex updating exclusive regions
Update the region between @var{beg} and @var{end} in the current buffer
as necessary due to the priority of an exclusive overlay overlapping the
region changing from @var{old-priority} to @var{new-priority}. If the
exclusive overlay did not previously overlap the region,
@var{old-priority} should be null. If it no longer overlaps the region,
@var{new-priority} should be null. (If both are null, nothing will
happen!) The return value is meaningless.


@item (auto-o-match-overlay @var{overlay} @var{start} @@optional @var{end} @var{no-props} @var{no-parse} @var{protect-match})
@findex auto-o-match-overlays
@cindex overlays, matching
@cindex matching overlays
@cindex extending, matching overlays
Match or unmatch the start and end of the auto-overlay @var{overlay},
update all appropriate properties (such as @code{parent}, @code{start}
and @code{end} properties, and any properties specified in regexp
definitions), and update other auto-overlays in the region covered by
@var{overlay} if required because the @code{exclusive} or
@code{priority} properties of @var{overlay} have changed.

If @var{start} or @var{end} are match overlays, match the corresponding
edge of @var{overlay}. The edge is moved to the location defined by the
match overlay, and the @code{parent} property of the match overlay and
the @code{start} and @code{end} properties of @var{overlay} are updated
accordingly. @var{start} should be a match overlay corresponding either
to the unique regexp if only one is needed for that overlay class, or to
a start regexp in a compound overlay class. @var{end} should be a match
overlay corresponding to an end regexp in a compound overlay
class. @xref{Overview}. However, no check is made to enforce this.

If @var{start} or @var{end} are numbers or markes, move the
corresponding edge of @var{overlay} to that location and make it
unmatched. The @code{start} or @code{end} property of @var{overlay} and
the @code{parent} property of any corresponding match overlay are set to
@code{nil}). If @var{start} or @var{end} are non-nil but neither of the
above, leave the corresponding edge of @var{overlay} where it is, but
make it unmatched (as described above). If @var{start} or @var{end} are
null, don't change the corresponding edge. However, for convenienve, if
@var{end} is null but @var{start} is a match overlay corresponding to a
match for an end-regexp, match the end of @var{overlay} rather than the
start.

The remaining arguments disable some of the tasks normally carried out
by @command{auto-o-match-overlay}. If @var{no-props} is non-nil, overlay
properties specified in regexp definitions are ignored and not
updated. If @var{no-parse} is non-nil, auto-overlays in the region
covered by @var{overlay} are not updated, even if the @code{exclusive}
or @code{priority} properties of @var{overlay} have changed. If
@var{protect-match} is non-nil, the @code{parent} properties of the
@var{start} and @var{end} match overlays are left alone.


@item (auto-o-delete-overlay @var{overlay} @@optional @var{no-parse} @var{protect-match})
@findex auto-o-delete-overlay
@cindex overlays, deleting
@cindex deleting overlays
@cindex extending, deleting overlays
Delete auto-overlay @var{overlay} from the buffer, and update overlays
and overlay properties as necessary. The optional arguments disable
parts of the updating process, as for @command{auto-o-match-overlay},
above.
@end table



@node Functions for Querying Overlays
@subsection Functions for Querying Overlays
@cindex functions, querying overlays
@cindex overlays, functions for querying
@cindex extending, functions for querying overlays
These functions query certain things about auto-overlays or match
overlays, or retrieve certain values associated with them. A few are
merely convenience functions, but most depend on the internal
implementation details of the auto-overlays package, and provide the
only reliable interface for whatever they return.

@table @code
@item (auto-o-class @var{o-match})
@findex auto-o-class
Return the class of match overlay @var{o-match}.

@item (auto-o-regexp @var{o-match})
@findex auto-o-regexp
Return the regular expression matched by the text covered by match
overlay @var{o-match}.

@item (auto-o-regexp-group @var{o-match})
@findex auto-o-regexp-group
Return the regexp group defined in the regexp definition corresponding
to match overlay @var{o-match} (@pxref{Defining Regexps}).

@c @item @c (auto-o-regexp-group-nth n @var{o-match})
@c @findex auto-o-regexp-group-nth
@c Return match overlay @var{o-match}'s Nth regexp group entry, or 0
@c if there is no Nth entry.

@item (auto-o-props @var{o-match})
@findex auto-o-props
Return the list of overlay properties defined in the regexp definition
corresponding to match overlay @var{o-match} (@pxref{Defining Regexps}).

@item (auto-o-edge @var{o-match})
@findex auto-o-edge
Return edge (the symbol @code{start} or @code{end}) of match overlay
@var{o-match} (assumes that @var{o-match}'s class is a compound class).

@item (auto-o-parse-function @var{o-match})
@findex auto-o-parse-function
Return appropriate parse function for match overlay @var{o-match}.

@item (auto-o-suicide-function @var{o-match})
@findex auto-o-suicide-function
Return appropriate suicide function for match overlay @var{o-match}.

@item (auto-o-match-function @var{o-match})
@findex auto-o-match-function
Return match function for match overlay @var{o-match}, if any.

@item (auto-o-edge-matched-p @var{overlay} @var{edge})
@findex auto-o-edge-matched-p
Return non-nil if @var{edge} (the symbol @code{start} or @code{end}) of
auto-overlay @code{overlay} is matched.

@item (auto-o-start-matched-p @var{overlay})
@findex auto-o-start-matched-p
Return non-nil if auto-overlay @var{overlay} is start-matched.

@item (auto-o-end-matched-p @var{overlay})
@findex auto-o-end-matched-p
Return non-nil if auto-overlay @var{overlay} is end-matched.
@end table



@node Auto-Overlay Hooks
@section Auto-Overlay Hooks
@cindex hooks
@cindex package, hooks
@cindex hooks, loading and unloading
The auto-overlays package defines two hooks, that are called when
auto-overlays are enabled and disabled in a buffer. These are intended
to be used by overlay classes to set up any extra buffer-local variables
and settings they require, and clean them up afterwards. (There is no
point leaving auto-overlay variables and settings hanging around in a
buffer when auto-overlays are not in use.)

@vtable @env
@item auto-overlay-load-hook
This hook is run when the first auto-overlay regexp set in a buffer is
started, using the @command{auto-overlay-start} function. @xref{Starting
and Stopping Auto-Overlays}.

@item auto-overlay-unload-hook
This hook is run when the last auto-overlay regexp set in a buffer is
stopped, using the @command{auto-overlay-stop} function. @xref{Starting
and Stopping Auto-Overlays}.
@end vtable




@node Auto-Overlay Modification Pseudo-Hooks
@section Auto-Overlay Modification Pseudo-Hooks
@cindex modification pseudo-hooks
@cindex hooks, modification
@cindex scheduling functions after modification
@cindex functions, scheduling
The auto-overlays package adds functions to buffer and overlay
modification hooks in order to update the overlays as the buffer text is
modified (@pxref{Modification Hooks,,,elisp,GNU Emacs Lisp Reference
Manual}). The order in which all these modification hooks are called is
undefined in Emacs@footnote{Or at least undocumented, and therefore
unreliable.}. Therefore, the auto-overlays package provides a mechanism
to schedule functions to run at particular points during the overlay
update process.

There are two stages to the overlay update process: first, any match
overlay suicide functions are called, then modified buffer lines are
scanned for new regexp matches. Three pseudo-hooks are defined that are
called before, after and in between these stages. Their values are lists
containing elements of the form:
@lisp
(@var{function} @var{arg1} @var{arg2} ...)
@end lisp
where @var{function} is the function to be called by the hook, and the
@var{arg}'s are the arguments to be passed to that function. The list
elements are evaluated in order. The pseudo-hooks are cleared each time
after they have been called.

@vtable @env
@item auto-o-pending-pre-suicide
Pseudo-hook called before any suicide functions.

@item auto-o-pending-post-suicide
Pseudo-hook called after any suicide functions but before scanning for
regexp matches.

@item auto-o-pending-post-update
Pseudo-hook called after scanning for regexp matches.
@end vtable

These pseudo-hooks can be used to ensure that a function that would
normally be added to a modification hook will be called at a particular
point in the auto-overlay update process. To achieve this, a helper
function must be added to the modification hook instead. The helper
function should add the function itself to the appropriate pseudo-hook
by adding a list element with the form described above. The
@command{push} and @command{add-to-list} Elisp functions are the most
useful ways to add elements to the list.



@node To-Do
@chapter To-Do
@cindex to-do
Things that still need to be implemented (in no particular order):

@enumerate
@item
There needs to be an @code{eager-self} overlay class, similar to the
existing @code{self} class but updated immediately, rather than waiting
for buffer modifications. This will be significantly less efficient, but
is necessary for applications that require overlays to be up to date all
the time, not just when the buffer is being modified.

@item
When loading overlay data from file, auto-overlays doesn't check whether
the regexp definitions used in the buffer are consistent with those that
were active when the data was saved. If implemented, it should be
possible to override it.

@item
Currently, it's difficult to deal with @code{nest} class regexps for
which the @code{end} regexps match some @code{start} regexps of interest
but also others that are irrelevant. E.g. @samp{@{} and @samp{@}} in
@LaTeX{} when you're only interested in @samp{\somecommand@{}
@code{start} regexps. Or matching parens in LISP, when you're only
interested in function bodies, say. The only solution is to include all
@code{start} regexps and give the irrelevant ones a null @code{dict}
property. This can end up creating a lot of overlays! A variant of the
@code{nest} class that avoids this problem is needed.
@end enumerate


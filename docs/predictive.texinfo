\input texinfo @c -*-texinfo-*-

@comment Documentation for the Emacs predictive completion mode

@c %**start of header
@setfilename predictive.info
@settitle Emacs Predictive Completion Manual
@c %**end of header


@copying
This manual describes the Emacs Predictive Completion package, version
0.8.
@c --version--

Copyright @copyright{} 2005 Toby Cubitt

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled "GNU Free
Documentation License".
@end quotation
@end copying


@titlepage
@title Emacs Predictive Completion Manual
@subtitle Version 0.8
@c --version--
@author Toby Cubitt

@c Start copyright page
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage


@ifnottex
@node Top
@top Emacs Predictive Completion Manual

@insertcopying

The package adds a new predictive completion minor-mode, called
@dfn{predictive} mode, to the GNU Emacs editor. Although there are many
options and customizations, the easiest way to start using it is to
simply install the package (@pxref{Obtaining and Installing}), and
insert the following in your @file{.emacs} file:

@lisp
(require 'predictive)
@end lisp

Alternatively, you can use

@lisp
(autoload 'predictive-mode "@var{/path/to/predictive.elc}")
@end lisp

@noindent
Turn on the minor-mode by running the @command{predictive-mode} command,
and start typing. Then come back and read up on how to tailor it to your
liking.
@cindex .emacs file
@cindex startup file
@cindex configuration file

@menu
* What is predictive completion?::  
* Obtaining and Installing::    
* Quick-Start::                 
* Completing Words::            
* Dictionaries::                
* Character Syntax and Key Bindings::  
* Working with Major Modes::    
* Bugs and Future Improvements::  
* Credits::                     
* Command Index::               
* Variable Index::              
* Concept Index::               
* Copying this Manual::         

@detailmenu
 --- The Detailed Node Listing ---

Completing Words

* Basic Completion Commands::   
* Dynamic Completion::          
* Offering a List of Completions::  
* Miscellaneous Options::       

Basic Completion Commands

* Inserting Completions::       
* Deleting Characters::         
* Jumping to Completions::      

Dictionaries

* Creating Dictionaries::       
* Loading and Saving Dictionaries::  
* Basic Dictionary Usage::      
* Automatic Dictionary Switching::  
* Dictionary Learning::         
* Buffer Dictionaries::         

Automatic Dictionary Switching

* Defining Regions::            
* Dictionary Switching Example::  
* Displaying Active Dictionaries in the Mode Line::  
* Low-Level Details::           

Defining Dictionary Regions

* word regexps::                
* line regexps::                
* stack regexps::               
* self regexps::                

Dictionary Learning

* Learning from Buffers and Files::  
* Automatic Learning::          

Character Syntax and Key Bindings

* Keymaps and Key Bindings::    
* Syntax::                      
* Functions for Binding to Characters::  

Bugs and Future Improvements

* Known Bugs::                  
* Future Improvements::         

Copying this Manual

* GNU Free Documentation License::

@end detailmenu
@end menu

@end ifnottex


@c table of contents
@contents



@node What is predictive completion?
@chapter What is predictive completion?
@cindex What is predictive completion?
@cindex predictive completion, introduction
@cindex completion, predictive

The languages we use to communicate contain a large amount of
redundancy. Given the first few letters of a word, for instance, it's
not too difficult to predict what should come next. Try it! You can
probably easily guess how to fill in the missing letters in the
following sentence:

@display
Giv th fir fe lett o a wor i no diffi t predi wh shou com nex.
@end display

This is even more true of the languages used to communicate with
computers, which typically have very restricted vocabularies and rigidly
defined grammars. Redundancy occurs on many levels: on the level of
individual characters (as illustrated above), on the level of words (we
can often predict quite accurately what words are likely to come next in
a sentence, based on grammar and usage), and perhaps even on higher
levels. Predictive completion exploits this redundancy by attempting to
complete what you are trying to type before you've finished typing it.

The predictive completion mode described here is an add-on to the GNU
Emacs editor, which implements a new minor-mode called @dfn{predictive
completion mode} (@pxref{Minor Modes, , , emacs, GNU emacs
manual}). When the predictive completion minor-mode is switched on,
Emacs will try to complete the word you are typing based on the
characters typed so far. As you add characters, it looks up words
starting with those characters in a dictionary, and offers to insert the
most likely ones. Exactly how you choose which completion (if any) to
insert depends on various settings, some more intrusive than others.

Note that by only taking into account characters belonging to the
current word when predicting how to complete it, much of the redundancy
in language remains unexploited. This limitation is partly for
simplicity. But also, some of the benefits of predictive completion
would be lost if context (i.e. the preceding words and sentences) was
also taken into account.

@noindent
What benefits does predictive completion bring?

@enumerate
@item
Saving on typing (obviously!): you don't have to type the whole word.
@cindex save on typing

@item
Automatic spelling assistance: when you type the first few characters of
a word, only correct spellings of the whole word are offered. This is
not only useful for human languages. The predictive completion mode can
be set up to complete on variable and function names in a program,
helping avoid bugs due to misspelled names.
@cindex automatic spelling assistance
@cindex spelling

@item
Faster typing: not quite the same as point 1. As you get used to
predictive completion, your fingers will start to learn the key
sequences required for frequently used words. And these key sequences
will usually be much shorter than typing the full word. (This is one
reason for not taking context into account. If we did, the same word
would require different key sequences depending on the words and
sentences preceding it.)
@cindex faster typing
@cindex type faster
@end enumerate




@node Obtaining and Installing
@chapter Obtaining and Installing
@cindex obtaining and installing
@cindex installation
@cindex obtaining

The current version of the predictive completion package can be obtained
from @uref{http://www.dr-qubit.org/emacs.php}. You will also need the
Emacs Lisp Library (Elib), available from @uref{http://jdee.sunsite.dk}.

To install the package, the files should be extracted to a directory in
the Emacs @env{load-path} (@pxref{Lisp Libraries, , , emacs, GNU Emacs
Manual}). You can view the current @env{load-path} using @kbd{C-h v
load-path} in Emacs, assuming default keybindings. All subdirectories
created by unpacking the package should also be in the @env{load-path}.

For performance reasons, it is important to byte-compile the lisp code,
at least for the core lisp files. You can do this by running
@command{make core} in the directory you extracted the files
to@footnote{For some unknown reason, byte-compiling the core lisp files
from the command line causes strange errors for me when running
predictive completion mode. If anyone knows why, let me know! Creating
the dictionaries works fine.}. Or you can do it manually using
@command{byte-compile-file} or one of the other Emacs byte-compilation
commands (@pxref{The Compilation Functions, , , elisp, GNU Emacs Lisp
Reference Manual}) for each of the following lisp files: @file{heap.el},
@file{tstree.el}, @file{dict.el}, @file{predictive.el},
@file{auto-overlays.el}, @file{auto-overlay-word.el},
@file{auto-overlay-line.el}, @file{auto-overlay-self.el},
@file{auto-overlay-stack.el} and
@file{dict-english.el}@footnote{Personally, I like to use @dfn{dired}
when byte-compiling multiple files. @xref{Operating on Files, , , emacs,
GNU Emacs manual}.}.

If you want the predictive completion minor-mode to be available
whenever you start Emacs, put the following line in your @file{.emacs}
file:

@example
(require 'predictive)
@end example

Alternatively, you can save memory and only load the lisp libraries when
they're needed (i.e. when you first run the @command{predictive-mode}
command), by putting the following in your @file{.emacs} instead:

@lisp
(autoload 'predictive-mode "@var{/path/to/predictive.elc}")
@end lisp
@cindex .emacs file
@cindex startup file
@cindex configuration file

The only pre-prepared dictionary included in the main package is the
English dictionary (so that predictive completion mode works ``out of
the box'', albeit slowly if you don't byte-compile). However, you will
get better results if you roll your own English dictionary and tailor it
to your writing style by teaching it the word frequencies from samples
of your writing (@pxref{Dictionaries})@footnote{You can get a word list
to use to create your own dictionary for instance by deleting the word
weights from the plain text @file{dict-english.word-list} file, or from
the @command{ispell} program or one of its substitutes.}.

Extra dictionaries for other languages (e.g. LaTeX) are supplied as
plain text word lists. Running @command{make dicts} creates these
dictionaries. You can, if you prefer, create them manually using the
@command{predictive-create-dict} command. If you do this, you should
give the dictionary the same file name as the word list file, minus the
final @file{-word-list}. @xref{Creating Dictionaries}.
@cindex dictionaries
@cindex dictionary packages

Running @command{make} will byte-compile the core lisp files as well as
creating the dictionaries.




@node Quick-Start
@chapter Quick-Start
@cindex quick-start
@cindex using predictive mode
@cindex predictive mode, using

Use the @command{predictive-mode} command to switch the predictive
minor-mode on. The same command will also switch it off again.
@findex predictive-mode

As you add characters to a word, predictive mode searches in a
dictionary for words starting with those characters. There are a number
of different ways to choose which word to use (if any) to complete what
you've already typed.

With the default settings, the most likely completion is provisionally
inserted in the buffer after the point, and highlighted to indicate that
it has not yet been accepted. The most likely completion is updated as
you add more characters to the word. Typing any end-of-word character
(such as a space or a punctuation character) accepts the
completion. @xref{Dynamic Completion}, for details.

What if you don't want to use the most likely completion? As you type, a
list of the ten most likely completions is displayed in the echo area,
ranked according to likelihood. Typing a number 0--9 will insert the
corresponding completion. @xref{Offering a List of Completions}, for
details.

Finally, you can cycle through the available completions using the
@kbd{predictive-cycle} command, bound to @kbd{M-TAB} by default. As you
cycle, the next available completion is provisionally inserted after the
point and highlighted. Typing any end-of-word character accepts the
completion, as usual. @xref{Basic Completion Commands}, for details.
@findex predictive-cycle

Another useful command is @kbd{predictive-scoot-ahead}, bound to
@kbd{TAB} by default@footnote{Actually, @kbd{TAB} is bound to the very
similar @command{predictive-scoot-or-cycle} command by default.}. This
inserts the characters from the current provisional completion as though
you typed them yourself, without ending the word. This means that new
completions of the resulting, longer string of characters will appear
--- useful if a word just needs a suffix adding, for instance.
@findex predictive-scoot-ahead

To get rid of a provisional completion and just leave the characters
you've typed, use the @kbd{predictive-abandon} command, bound to
@kbd{M-SPACE} by default.
@findex predictive-abandon





@node Completing Words
@chapter Completing Words
@cindex completing words
@cindex completion

As you type, predictive mode is continually searching behind the scenes
for the most likely completions of the words you are typing. However,
how you make use of these depends on how intrusive you want it to
be. The many options and settings let you customize it to your needs.

Predictive mode can work completely unobtrusively, so that using it has
no discernible effect until you issue a command to insert a completion
(@pxref{Basic Completion Commands}). It can be slightly more intrusive,
so that you always see which completions are available, but can still
ignore them and type normally if you wish (@pxref{Offering a List of
Completions}). Or it can work more intrusively still, by always
provisionally inserting the most likely completion (@pxref{Dynamic
Completion}). This is probably the most effective way to use predictive
mode, but it does mean slightly changing the way you type.

Note that all predictive mode commands and variables start with
@samp{predictive-} to distinguish them from other minor- and major-mode
commands.

@menu
* Basic Completion Commands::   
* Dynamic Completion::          
* Offering a List of Completions::  
* Miscellaneous Options::       
@end menu


@node Basic Completion Commands
@section Basic Completion Commands
@cindex basic completion commands
@cindex completion, basic commands
@cindex commands, basic

The minor-mode command @command{predictive-mode} toggles the mode on and
off. With a non-nil prefix argument it switches the mode on, whilst a
null prefix argument turns it off. The @command{turn-on-predictive-mode}
is also provided as a convenience for use in hooks.
@findex predictive-mode
@findex turn-on-predictive-mode

@menu
* Inserting Completions::       
* Deleting Characters::         
* Jumping to Completions::      
@end menu



@node Inserting Completions
@subsection Inserting Completions
@cindex inserting completions
@cindex completions, inserting

@ftable @command
@item predictive-cycle
(@kbd{M-TAB}, @kbd{M-SHIFT-TAB}) Cycle through available
completions. When supplied with a prefix argument, it will jump that
many completions forwards (or backwards if the prefix argument is
negative).

@item predictive-complete-word-at-point
(@kbd{M-TAB}) Find completions for the word at or next to the point.
@end ftable

@vindex predictive-accept-if-point-moved
@command{predictive-cycle} is the most useful completion command if
dynamic completion and the completion list are disabled. It cycles
through the available completions for the current word, provisionally
inserting them after the point and highlighting them to indicate they
have not been accepted yet. In the default key bindings, @kbd{M-TAB}
cycles forwards and @kbd{M-SHIFT-TAB} cycles backwards.

To accept a completions, simply type any end-of-word character
(@pxref{Character Syntax and Key Bindings}).  Moving the point elsewhere
and typing something will also work if
@env{predictive-accept-if-point-moved} is enabled (@pxref{Miscellaneous
Options}).

Normally, predictive mode finds completions as you type. Occasionally,
you may need to manually force it to look for completions of a word
using @command{predictive-complete-word-at-point}. If dynamic completion
and the completion list are disabled, this will not have any obvious
effect, but it means you can use @command{predictive-cycle} to cycle
through the completions it has found.

Note that @command{predictive-complete-word-at-point} and
@command{predictive-cycle} do not conflict even though they are bound to
the same key (though in different key-maps, @pxref{Character Syntax and
Key Bindings}). @command{predictive-cycle} only works if there are
completions to cycle through, whereas
@command{predictive-complete-word-at-point} is only needed if no
completion is in progress.


@node Deleting Characters
@subsection Deleting Characters
@cindex deleting characters
@cindex characters, deleting

@ftable @command
@item predictive-backward-delete
Remove characters from the string currently being completed, and find
new completions for the resulting shorter string. A prefix argument
specifies the number of characters to remove. If this is larger than or
equal to the length of the string being completed, only that string is
deleted and the completion is abandoned. If no completion is in
progress, behaviour is identical to the Emacs
@command{backward-delete-char-untabify} command.

@item predictive-backward-delete-and-complete
@kbd{DEL} Delete characters backwards, and complete whatever string is
then in front of the point. The prefix argument specifies how many
characters to delete.
@end ftable

When in the middle completing a word, both these commands remove
characters backwards, and find completions for the remaining, shorter
string. They differ slightly in what they do if you try to delete more
characters than are in the current word, and how they behave when no
completion is in progress.

When a completion is in progress, a single
@command{predictive-backward-delete} command will not delete beyond the
current word. If it reaches the beginning of the word, completion is
abandoned, but no further characters are removed. If no completion is in
progress, it behaves exactly like the Emacs
@command{backward-delete-untabify} command (i.e. it deletes the
specified number of characters backwards, converting tabs to spaces in
the process).

@command{predictive-backwards-delete-and-complete} deletes however many
characters you specify (converting tabs to spaces like
@command{backward-delete-untabify}), even if a completion is in progress
and this will delete beyond the current word. Whether or not a
completion is in progress, once it has deleted the characters, it tries
to complete whatever word is then next to the point (like using
@command{predictive-complete-word-at-point} after deleting,
@pxref{Inserting Completions})).
@findex predictive-complete-word-at-point



@node Jumping to Completions
@subsection Jumping to Completions
@cindex jumping to completions
@cindex completions, jumping to
@cindex find old completions

@ftable @command
@item predictive-jump-to-current-completion
Move point to current completion.

@item predictive-jump-to-old-completion
Jump to the last completion that was automatically accepted or abandoned
because the had point moved.
@end ftable

Whilst a completion is in progress, you can still move the point
elsewhere in the buffer. The
@command{predictive-jump-to-current-completion} command will return the
point to the word being completed.

It would be confusing if provisional completions were left in limbo when
you move the point away and start typing (and completing)
elsewhere. Therefore whenever you start a new completion when an old one
is still in progress, the old completion is either accepted or abandoned
automatically, depending on the setting of the variable
@env{predictive-accept-if-point-moved} (@pxref{Miscellaneous Options}).

Since you may want to return to the old completion to check if it's
correct, the @command{predictive-jump-to-old-completion} command
exists. (Note that only one old completion is stored and can be returned
to.)

@vindex predictive-accept-if-point-moved



@node Dynamic Completion
@section Dynamic Completion
@cindex dynamic completion
@cindex completion, dynamic
@vindex predictive-dynamic-completion

When dynamic completion is enabled, the most likely completion is
provisionally inserted in the buffer after the point and highlighted to
indicate that it has not yet been accepted. Typing more word-constituent
characters adds them to the word, and updates the most likely
completion. Typing any end-of-word character (such as a space or a
punctuation character) accepts the completion.

Dynamic completion is enabled when the
@env{predictive-dynamic-completion} variable is non-nil (the default),
and disabled when it is nil.

The current syntax table (@pxref{Syntax, , , emacs, GNU Emacs Manual})
determines which characters are word-constituents and which are not
(although the behaviour of individual characters can be
overridden). @xref{Character Syntax and Key Bindings}, for details.

@noindent
The following commands help control dynamic completion:

@ftable @command
@item predictive-accept
Accept the current completion, and move the point just beyond it.

@item predictive-abandon
(@kbd{M-SPACE}) Abandon the current completion, removing the
provisionally inserted (i.e. highlighted) characters.
@end ftable

Note that since the @command{predictive-abandon} command ends the
completion process, if you want to find completions for the word again
you have to do it manually with
@command{predictive-complete-word-at-point}. @xref{Inserting
Completions}.
@findex predictive-complete-word-at-point

@ftable @command
@item predictive-scoot-ahead
(@kbd{M-TAB}) Insert the characters from the current completion as
though typed manually, without ending the completion process, and look
for completions of the resulting, longer string.

@item predictive-scoot-or-accept
If there are no characters to insert from the current completion accept
the completion. Otherwise behaviour is as for
@command{predictive-scoot-ahead}.

@item predictive-scoot-or-cycle
If there are no characters to insert from the current completion, cycle
to the next available completion. Otherwise behaviour is as for
@command{predictive-scoot-ahead}.
@end ftable

The scoot-ahead commands provide a convenient way to use the characters
from the current, provisional completion without accepting it as
final. Predictive mode will find completions for the resulting, longer
string, and you will still be able to add or remove characters from it.

@command{predictive-scoot-or-accept} and
@command{predictive-scoot-or-cycle} change their behaviour when there
are no characters to add from the completion, i.e. the most likely
completion of what's been typed is the typed word itself. They then
behave like @command{predictive-accept} and @command{predictive-cycle},
respectively (@pxref{Inserting Completions}).
@findex predictive-accept
@findex predictive-cycle



@node Offering a List of Completions
@section Offering a List of Completions
@cindex offering a list of completions
@cindex completion, offering list of
@cindex list of completions
@cindex completions, list of
@vindex predictive-offer-completions

When the variable @env{predictive-offer-completions} is non-nil,
predictive mode will display a list of the most likely completions in
the echo area whenever a completion is in progress, ordered by
likelihood. This is enabled by default. The character in brackets in
labeling each completion in the list can be used to insert the
corresponding completion (the numerical characters 0--9 are used by
default).

@noindent
The following variables affect the behavior of the completions list:

@vtable @env
@item predictive-accept-on-select
Controls the behaviour produced by selecting a completion from the
list. When non-nil (the default), the selected completion is inserted
and accepted. When nil, the selected completion is inserted, and the
resulting, longer string is completed anew.

@item predictive-offer-completions-keylist
List of characters to use for selecting completions from the list. The
number of completions offered in the completions list is determined by
the number of characters in this list. Default is numerical characters 0
to 9. @xref{Keymaps and Key Bindings}.
@end vtable

However many characters are in
@env{predictive-offer-completions-keylist}, the completion list cannot
offer more completions than were found. The maximum number to find is
limited by @env{predictive-max-completions}, @ref{Miscellaneous
Options}.
@vindex predictive-max-completions



@node Miscellaneous Options
@section Miscellaneous Options
@cindex miscellaneous options
@cindex completion, miscellaneous options

@noindent
The following variables affect the overall behaviour of predictive mode:

@vtable @env
@item predictive-max-completions
Maximum number of completions to find. Default is 10.
@end vtable

Setting @env{predictive-max-completions} to a large number is probably
not useful, and will slow predictive mode down. It is easier to type a
few extra characters than cycle through lots of completions, and the
number available in the completion list is limited by the number of
characters used to select them (@pxref{Offering a List of Completions}).

@vtable @env
@item predictive-ignore-initial-caps
Controls whether predictive mode should ignore initial capital letters
when searching for completions. If non-nil (the default), completions
for the uncapitalized string are also found.
@end vtable

Only the @emph{first} capital letter of a string is ignored. Thus typing
@kbd{A} would find @samp{and} (@samp{And} would be inserted),
@samp{Alaska} and @samp{ANSI}, but typing @kbd{AN} would only find
@samp{ANSI}, whilst typing @kbd{a} would only find @samp{and}.

@vtable @env
@item predictive-always-complete
Makes predictive mode try to complete words even when nothing has been
typed yet. This has the effect of making the most likely words in whole
the dictionary available. Disabled by default to protect your sanity!

@item predictive-accept-if-point-moved
Determines what to do with a provisional completion if you move the
point away from it and start typing elsewhere. If non-nil (the default),
the old completion is accepted. If nil, it is abandoned instead. A
message is displayed in the echo area to warn you.
@end vtable




@node Dictionaries
@chapter Dictionaries
@cindex dictionaries

Predictive completion is only as good as the dictionary it uses. The
dictionary doesn't only list the words themselves, it also ranks them
according to how likely they are, so that predictive mode can offer the
most likely completions first. As you type, predictive mode can learn
which words you use more frequently, so that the predictions improve. It
is not restricted to using one dictionary at a time; it can
automatically switch dictionaries in regions of text defined by regular
expressions, use many dictionaries in parallel, and store some words in
a special dictionary local to each buffer. And it attempts to find the
completions faster than you type, so that your typing is not slowed down
even when using very large dictionaries.

@menu
* Creating Dictionaries::       
* Loading and Saving Dictionaries::  
* Basic Dictionary Usage::      
* Automatic Dictionary Switching::  
* Dictionary Learning::         
* Buffer Dictionaries::         
@end menu



@node Creating Dictionaries
@section Creating Dictionaries
@cindex creating dictionaries
@cindex dictionary, creating

Predictive mode dictionaries store words along with their associated
weights, used to rank the words in order of likelihood. The weight is
just an integer value, which can be thought of as the relative frequency
of a word.

@noindent
The following commands are used to manually create and update
dictionaries:

@ftable @command
@item predictive-create-dict
Create a new dictionary. The dictionary name is read from the
mini-buffer. You can optionally supply a filename to associate with the
dictionary. The dictionary will be saved to this file by default (just
as a buffer is saved to its associated file). You may also supply a file
containing a list of words with which to populate the new
dictionary. The @env{predictive-completion-speed} and
@env{predictive-dict-autosave} variables set the new dictionary's
completion speed and autosave flag (see below).
@vindex predictive-completion-speed
@vindex predictive-dict-autosave

@item predictive-add-to-dict
Insert a word into a dictionary. The dictionary name and word are read
from the mini-buffer. An optional prefix argument specifies the
weight. If the word is not already in the dictionary, it will be added
to it with that initial weight (or 0 if none is supplied). If the word
is already in the dictionary, its weight will be incremented by the
weight value (or by 1 if none is supplied).

@item predictive-boost-prefix-weights
Inrease the weight of a word that is also a prefix for other words
(e.g. @samp{boost} is a prefix for @samp{boosting}, so @samp{boosting}
is a completion of @samp{boost}). Specifically, if the weight of the
prefix is lower than any of its completions, its weight will be set to
the maximum weight of its completions. Otherwise, it will be left
unchanged. The dictionary name and prefix word are read from the
minibuffer. Leaving the prefix word blank will boost all prefices in the
dictionary that are longer than a minimum length specified by the prefix
argument.

@item dict-size
Display the number of words in a dictionary.
@end ftable

Note that there is currently no @command{predictive-remove-from-dict}
command to remove a word from a dictionary. @xref{Known Bugs}.

The file containing the list of words used to populate a dictionary has
to conform to a specific format. Each line contains one word, delimited
by @samp{""}, optionally followed by an integer separated by whitespace
from the word itself, which specifies the word's weight. Any characters
before the first @samp{"} are ignored. Note that the `words' in a
dictionary do not have to be words in the usual sense. They can be
arbitrary sequences of characters, including whitespace and punctuation
characters. The quote character @samp{"} can be included by escaping it:
@samp{\"}. However, see @ref{Known Bugs}.

To ensure it is as efficiently structured as possible, it is best to
create a dictionary from a list of words using
@command{predictive-create-dict}, rather than create a blank dictionary
and add the words using @command{predictive-add-to-dict}. For small
dictionaries it won't make much difference, but for larger ones it can
be significant.

It is often more useful for words that are prefices for others to have
higher weights, especially when using dynamic completion and the
@command{predictive-scoot-ahead} command (@pxref{Dynamic
Completion}). The @command{predictive-boost-prefix-weights} command
manipulates word weights to ensure that this is the case.

@noindent
The following variables set other dictionary properties:

@vtable @env
@item predictive-completion-speed
Sets the default completion speed of dictionaries created with
@command{predictive-create-dict}. This is the desired upper limit on the
time it takes to find completions; there is no guarantee it will be
achieved! If it takes longer than this to find a particular completion,
the results are cached so that they can be retrieved faster next
time. Thus lower values result in faster completion, at the expense of
dictionaries taking up more memory. Note that individual dictionaries
can override this value, if a completion-speed is specified when they
are created.

@item predictive-dict-autosave
Sets the default autosave property for dictionaries created with
@command{predictive-create-dict}. If non-nil, modified dictionaries will
automatically be saved when it is unloaded (either with the
@command{predictive-dict-unload} command, or when exiting emacs). If
nil, any unsaved modifications will be lost. @xref{Loading and Saving
Dictionaries}.
@cindex predictive-dict-unload
@end vtable



@node Loading and Saving Dictionaries
@section Loading and Saving Dictionaries
@cindex loading and saving dictionaries
@cindex dictionaries, loading
@cindex dictionaries, saving

@ftable @command
@item dict-load
Load a dictionary from file. The name given to the loaded dictionary is
the same as the file name, with the extension removed. This will not add
it to the list of dictionaries used by the current buffer (see
@command{predictive-load-dict}, below).

@item predictive-load-dict
Load a dictionary, and add it to the list of dictionaries used by the
current buffer. The dictionary file must be in your @env{load-path}. The
dictionary will be included when learning from the buffer, see
@ref{Learning from Buffers and Files}.

@item dict-unload
Unload a dictionary. If the dictionary's autosave flag is set, this will
also save it (@pxref{Creating Dictionaries}).

@item dict-save
Save a dictionary to its associated file. Prompt for a file name if
there is none associated with the dictionary.

@item dict-write
Write a dictionary to a file specified via the mini-buffer. This also
associates the dictionary with that file. If a prefix argument is
supplied, you will @emph{not} be asked to confirm if over-writing an
existing file.

@item dict-save-modified
Save all modified dictionaries. If a prefix argument is supplied,
confirm each dictionary before saving.

@item dict-dump-words-to-buffer
Dumps all words and weights in the dictionary to a buffer, in the
same format as that used to populate dictionaries (@pxref{Creating
Dictionaries}).

@item dict-dump-words-to-file
Dumps words and weights to a text file rather than a buffer. If a prefix
argument is supplied, you will @emph{not} be asked to confirm if
over-writing an existing file.
@end ftable

To use a dictionary, it must be loaded into memory. This can be done
manually, using the @command{dict-load} or
@command{predictive-load-dict} commands. Alternatively, if you want the
dictionary to be loaded every time you run Emacs, you can add the
following line to your @file{.emacs} file:

@lisp
(require '@var{dictionary-name})
@end lisp

@noindent
The major-mode setup functions load the dictionaries they need
automatically. @xref{Working with Major Modes}.

A buffer is usually associated with a file, and saving the buffer with
the Emacs @command{save-buffer} command writes any changes back to that
file. Similarly, dictionaries are usually associated with a dictionary
file. The @command{dict-save} command saves any changes back to that
file. The @command{dict-write} command is analogous to the Emacs
@command{write-file} command.

Dictionaries can be modified by adding words to them with the
@command{predictive-add-to-dict} command (@pxref{Creating
Dictionaries}). If the auto-learn features are used, dictionaries are
modified whenever a completion is accepted (@pxref{Automatic
Learning}). The @command{dict-save-modified} saves all modified
dictionaries.



@node Basic Dictionary Usage
@section Basic Dictionary Usage
@cindex basic dictionary usage
@cindex dictionaries, basic usage
@cindex dictionaries, using
@vindex predictive-main-dict

The name of the main dictionary used by a buffer is stored in the
buffer-local @env{predictive-main-dict} variable. Note that the variable
contains the @emph{name} of the dictionary (a symbol), which must
already be loaded (@pxref{Loading and Saving Dictionaries}), not the
dictionary itself. This is the dictionary predictive mode will normally
search for words in.

@env{predictive-main-dict} can also hold a list of dictionary
names. They are then treated as though they form one combined
dictionary. However, when @env{predictive-auto-add-to-dict} is used,
words are always added to the first dictionary in the
list. @xref{Automatic Learning}.
@vindex predictive-auto-learn
@vindex predictive-auto-add-to-dict



@node Automatic Dictionary Switching
@section Automatic Dictionary Switching
@cindex dictionaries, automatic switching
@cindex dictionaries, switching
@cindex dictionaries, using multiple
@cindex automatic dictionary switching
@cindex switching dictionaries automatically
@cindex changing dictionaries automatically
@cindex using multiple dictionaries
@cindex multiple dictionaries

When typing an ordinary piece of text, you may well only need to use one
dictionary. But when typing something more complex, such as a La@TeX{}
document or a c program, it can be useful to switch back and forth
between different dictionaries. For example, you might switch to a
dictionary of markup tags when you want to insert one, then switch back
to an English dictionary afterwards. You could manually set
@env{predictive-main-dict} every time you wanted to change dictionary,
but it would be even more useful if predictive mode could automatically
switch dictionaries for you.

Predictive mode uses the @dfn{auto-overlays} package (included with the
predictive package and written specifically for it) to provide a
powerful mechanism for automatically detecting when to switch
dictionaries, based on defining text regions via regular expression
delimiters.

@menu
* Defining Regions::            
* Dictionary Switching Example::  
* Displaying Active Dictionaries in the Mode Line::  
* Low-Level Details::           
@end menu


@node Defining Regions
@subsection Defining Dictionary Regions
@cindex defining dictionary regions
@cindex dictionaries, defining regions
@cindex dictionary switching, defining regions
@cindex regexp list

To initialise regions within which an alternative dictionary is active,
@command{auto-overlay-init} must be called with an argument that defines
the regexps and dictionaries. This should almost always be done in a
setup function (@pxref{Working with Major Modes}). The argument to
@code{auto-overlay-init} should be a list, each element of which should
itself be a list with one of the following forms:

@lisp
(@var{class} @var{regexp} @@rest @var{props})
@end lisp

@lisp
(@var{class} (@var{edge} @var{regexp} @@rest @var{props})
             (@var{edge} @var{regexp} @@rest @var{propr}) ...)
@end lisp

@noindent
I.e. in the most complicated case, it can be a list of lists of lists
(this is where the @i{LIS}t @i{P}rocessor lives up to its name!)

The @var{class} element defines the behaviour of the switch-dictionary
region, and must be one of the four symbols: @code{'word}, @code{line},
@code{self} or @code{stack}, which are described in detail
below@footnote{It is possible to define your own classes, but that is
beyond the scope of this manual.}

The @var{edge} element should be one of the symbols @code{start} or
@code{end}, and indicates whether the regexp defines a start or end
delimiter.

The @var{regexp} element can either be a regular expression (i.e. a
string that defines a valid regular expression, @pxref{Regular
Expressions, , , elisp, GNU Emacs Lisp Reference Manual}, or a cons cell
containing a regexp in its @code{car} and an integer in its @code{cdr}
(whose significance is explained below). The only restriction on the
regexp is that it should not match text across more than one line.

The remaining optional @var{props} elements should be cons cells of the
form:

@lisp
(@var{property} . @var{value})
@end lisp

@noindent
@code{property} is a property name (a symbol), and @code{value} the
corresponding value to set it to. To activate an alternative predictive
mode dictionary in the region, use the @code{dict} property, whose value
can either be the name of a dictionary (a symbol) or the dictionary
itself. You must ensure that the dictionary is loaded before it is used
(it should probably be loaded in a startup function, @pxref{Working with
Major Modes}). The values @code{predictive-main-dict} and @code{t} are
dealt with as special cases. @code{predictive-main-dict} indicates that
the dictionary should revert to the default, i.e. a list containing
@code{predictive-main-dict} and the buffer dictionary (see @pxref{Buffer
Dictionaries}). The value @code{t} indicates that no dictionary should
be active at all.

The only properties you are likely to need (other than @code{dict}), are
@code{priority} and @code{exclusive}. The value of the @code{priority}
property should be a number. It determines which switch-dictionary
region takes priority in setting the dictionary when two overlap, with
larger values taking precedence (@pxref{Low-Level Details}). It is a
good idea to order the regexps within the regexp list by priority, from
highest to lowest.

Normally, the different regions exist completely independently; they
have no effect on each other, apart from a higher priority region
`masking' any lower priority one it overlaps. Sometimes it is useful to
block matches for other regexps entirely when another region is active
(e.g. for comments in markup and programming languages: any other
delimiters within the comment should be ignored). You can do this by
setting the @code{exclusive} property to a non-nil value.

The different `classes' of regexp cover the different ways that
switch-dictionary regions may need to be delimited:

@menu
* word regexps::                
* line regexps::                
* stack regexps::               
* self regexps::                
@end menu


@node word regexps
@subsubsection @code{word} regexps
@cindex word regexps
@cindex dictionary switching, word regexps

A @code{word} regexp defines a dictionary switch which only lasts for a
single word. All the text matched by the regexp is considered part of
the word, and forms the region where the dictionary is active. However,
if you want the switch-dictionary region to start and end @emph{within}
the matched text, you can use a cons cell of the form:

@lisp
(@var{regexp} . @var{group})
@end lisp

@noindent
in place of the regexp, as described previously. The @var{regexp} should
be a string defining a valid regular expression, as before, but groups
within the regexp (portions of the regexp surrounded by @samp{\(} and
@samp{\)}) are now significant. The @var{group} integer specifies which
subgroup of the regexp forms the region. The rest of the regexp must
still match, but the switch-dictionary region will only cover the part
of the text matching the specified subgroup.

A @code{word} regexp can not be combined with others in a list. It must
appear on its own as a separate element of the regexp list.


@node line regexps
@subsubsection @code{line} regexps
@cindex line regexps
@cindex dictionary switching, line regexps

A @code{line} regexp defines a dictionary switch that lasts till the end
of the line. The switch-dictionary region extends from just after
the text matching the regexp, to the end of the line. However, if you
want the region to start @emph{within} the matched text, you can do so
by using a cons cell of the form:

@lisp
(@var{regexp} . @var{group})
@end lisp

@noindent
in place of the regexp, as described previously (see @pxref{word
regexps}). The @var{group} integer specifies which subgroup of the
regexp defines the start of the region. The region will start from the
end of the text matching that subgroup.

A @code{line} regexp can not be combined with others in a list. It must
appear on its own as a separate element of the regexp list.


@node stack regexps
@subsubsection @code{stack} regexps
@cindex stack regexps
@cindex start regexps
@cindex end regexps
@cindex dictionary switching, stack regexps
@cindex dictionary switching, start and end regexps

@code{stack} regexps match the beginning and end of a switch-dictionary
region. Text that matches such a regexp establishes an opening or
closing delimiter, and the regions stretch between paired
delimiters. ``Between'' normally means from just after the end of the
text matching the @code{start} delimiter to just before the beginning of
the @code{end} delimiter (this can be modified, see below).

A @code{stack} regexp @emph{must} be combined with others in a list. The
list should contain at least one regexp whose @code{edge} is
@code{start} and one whose @code{edge} is @code{end}. The order of
regexps in the list is significant: if two regexps in the list could
match overlapping pieces of text, the one appearing first in the list
takes precedence and the other is ignored.

All @code{end} regexps in the list can pair with all @code{start}
regexps in the list to define a region. However, nothing requires the
dictionaries (or other properties) associated with the regexps to be the
same. Which dictionary takes precedence is again determined by which
regexp appears earliest in the list. A @code{start} and an @code{end}
regexp in the same list may @emph{not} match overlapping pieces of text;
the regexps must be defined so that this is impossible, or your teeth
might turn green, your hair could fall out, and other strange behaviour
may result.

Unpaired @code{end} and @code{start} delimiters create switch-dictionary
regions that stretch to the beginning or end of the buffer,
respectively, until a delimiter is inserted to pair with it.

If the buffer contains paired @code{start} and @code{end} delimiters of
the same type (i.e. the regexps are in the same list) nested inside one
another, these will define multiple switch-dictionary regions nested one
inside the other. Usually, the innermost region will take precedence
when two regions overlap. However, an outer region with a larger
@code{priority} (see above) takes precedence over an inner one with a
lower or non-existent @code{priority}.

Occasionally, you may want the switch-dictionary region to start or end
somewhere @emph{within} the text matching the regexps. This can be
achieved by using a cons cell of the form:

@lisp
(@var{regexp} . @var{group})
@end lisp

@noindent
in place of the regexp, as described previously (see @pxref{word
regexps}). The @var{group} integer specifies which subgroup of the
regexp forms the delimiter. The rest of the regexp must still match, but
the delimiter is formed only by the part of the text matching the
specified subgroup. The switch-dictionary region will therefore stretch
from the end of the specified subgroup of the @code{start} regexp, to
the start of the subgroup of the @code{end} regexp.

In this case, the restriction on @code{start} and @code{end} regexps in
the same list not being allowed to match overlapping pieces of text is
loosened slightly: the subgroups defining the delimiter parts of two
regexps in the same list are not allowed to match overlapping pieces of
text, but the non-delimiter parts may overlap.


@node self regexps
@subsubsection @code{self} regexps
@cindex self regexps
@cindex dictionary switching, self regexps

A @code{self} regexp matches both the beginning @emph{and} end of a
switch-dictionary region. Between two such delimiters, the dictionary
associated with the regexp will be active. (Note that this can not be
achieved using the @code{start} and @code{end} regexps described above,
since whichever comes first in the list will always match first,
preventing whichever comes second from ever matching.) @code{self}
regexps can not be combined with others in a list.

As in the case of @code{stack} regexps (@pxref{stack regexps}),
``between'' means from the end of the text matching one regexp to the
beginning of the text matching the next. And as before, this can be
modified by using a cons cell containing a regexp and an integer in
place of the regexp (@pxref{word regexps}). Since the same delimiter can
match the beginning or end of a region, overlapping regions can never be
created.



@node Dictionary Switching Example
@subsection Dictionary Switching Example
@cindex dictionary switching, example
@cindex example of dictionary switching

The interaction of all the different settings, properties and behaviours
provided by predictive mode's dictionary switching can be a little
confusing. This section will go through an example of how the the regexp
list could be set up for typing La@TeX{}. La@TeX{} is complex enough to
demonstrate most of the dictionary switching features. However, the
example in this section will not be a complete La@TeX{} setup. (A more
complete La@TeX{} setup is included in the predictive mode package,
@pxref{Obtaining and Installing}).

La@TeX{} is a markup language, so a La@TeX{} document combines commands
with normal text. Commands start with @samp{\}, and end at the first
non-word-constituent character. The only two commands we will be
concerned with are @samp{\begin} and @samp{\end}, which begin and end a
La@TeX{} environment. La@TeX{} provides many environments, used to
create lists, tables, titles, etc. We will take the example of an
@samp{equation} environment, used to typeset mathematical
equations. Thus equations are enclosed by @samp{\begin@{equation@}} and
@samp{\end@{equation@}}.

Another example we will use is the @samp{$} delimiter. Pairs of
@samp{$}s delimit mathematical expressions that appear in the middle of
a paragraph of normal text (whereas @samp{equation} environments appear
on their own, slightly separated from surrounding text). The final
example is the @samp{%} character, which creates a comment that lasts
till the end of the line (i.e. text after the @samp{%} is ignored by the
La@TeX{} processor).

La@TeX{} commands are a good example of when to use @code{word} regular
expressions (@pxref{word regexps}). When a @samp{\} is typed, we would
like predictive mode to switch to a dictionary of La@TeX{} commands, and
this switch should last until the entire command has been typed
(La@TeX{} commands end at the first non-letter character after the
@samp{\}). A @code{word} regexp does exactly this, so we will use one in
our regexp list, which at this point contains:

@lisp
(('word "\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)" ('dict . 'dict-latex)))
@end lisp

@noindent
@code{"\\\\"} is the string defining the regexp that matches a
@emph{single} @samp{\}. The @samp{\} character has a special meaning in
regular expressions, so to include a literal one it must be escaped:
@samp{\\}. However, @samp{\} also has a special meaning in lisp strings,
so both @samp{\} characters must be escaped there too, giving
@code{"\\\\"}.

@samp{[[:alpha:]]*?} matches a sequence of zero or more letter
characters. The @samp{?} ensures that it matches the @emph{shortest}
sequence of letters consistent with matching the regexp, since we want
the region to end at the first non-letter character, matched by
@samp{[^[:alpha:]]}. The @samp{\|} defines an alternative, to allow the
command to be terminated either by a non-letter character or by the end
of the line (@samp{$}). @xref{Regular Expressions, , , elisp, GNU Emacs
Lisp Reference Manual}, for more details on Emacs regular expressions.

This example assumes that @code{dict-latex} is the name of a loaded
predictive mode dictionary containing all the La@TeX{} commands. (The
correct place to load the dictionary is in a predictive major mode
setup function, @pxref{Working with Major Modes}).

However, there's a small problem. We only want the dictionary switch to
be active for the characters making up a La@TeX{} command. But as we've
defined things so far, it will be active for all the text matched by the
regexp, which includes the leading @samp{\} and the trailing non-letter
character. To rectify this, we need to group the part of the regexp that
matches the command (i.e. by surround it with @samp{\(} and @samp{\)}),
and put the regexp inside a cons cell containing the regexp in its
@code{car} and a number indicating which subgroup to use in its
@code{cdr}:

@lisp
(('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

The @samp{$} delimiter is an obvious example of when to use a
@code{self} regexp (@pxref{self regexps}). We can update our example to
include this:

@lisp
(('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex))
 ('self "\\$" ('dict . 'dict-latex-math)))
@end lisp

@noindent
@samp{$} also has a special meaning in regular expressions, so it must
be escaped with a @samp{\} which itself must be escaped in lisp
strings. The @code{dict-latex-math} dictionary should contain La@TeX{}
maths commands.

This won't quite work though. La@TeX{} maths commands also start with a
@samp{\} character, which will match the @code{word} regexp. Since the
@code{word} switch-dictionary region will be within the @code{self}
region, it will take precedence. We can change this by giving the
@code{self} delimiter a higher priority (any priority is higher than a
non-existent one; we use 3 here for later convenience). Remembering that
it's a good idea to put higher priority regexps before lower priority
ones, we get:

@lisp
(('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

@noindent
Predictive mode will now correctly switch to the maths dictionary and
use it in preference to the normal La@TeX{} command dictionary when you
are typing text enclosed by @samp{$} delimiters.

The @samp{\begin@{equation@}} and @samp{\end@{equation@}} commands also
enclose maths regions, so we would like predictive mode to switch to the
maths dictionary between these too. Since the opening and closing
delimiters are different in this case, we must use @code{stack} regexps
(@pxref{stack regexps}). Our list now contains:

@lisp
(('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

@noindent
Notice how we've used a list of @code{start} and @code{end} regexps to
define the region. Once again, we have had to escape the @samp{\}
characters, and increase the priority of the region.

La@TeX{} comments start with @samp{%} and last till the end of the
line: a perfect demonstration of a @code{line} regexp. We want the
dictionary to revert to the default, so we set it to
@env{predictive-main-dict}.

@lisp
(('self "\\$" ('dict . 'predictive-main-dict) ('priority . 3))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex))
 ('line "%" 'dict-english))
@end lisp

Let's think about this a bit. We probably don't want to switch
dictionaries for La@TeX{} commands within a comment. Not only do we not
want it, creating regions for @samp{\begin} and @samp{\end} commands
which are within a comment could cause havoc! If they don't occur in
pairs within the commented region, they will erroneously pair up with
ones outside the comment. We need comments to take precedence over
everything else, and we need them to block other regexps:

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

We're well on our way to creating a useful setup, at least for the
La@TeX{} commands we're considering in this example. There is one last
dictionary switch to create, but it is the most complicated. When
@samp{\begin@{} is typed, predictive mode should switch to a dictionary
of La@TeX{} environment names, until it encounters a @samp{@}}
character. A first attempt at this might result in:

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" ('dict . 'dict-latex-env) ('priority . 2)))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

@noindent
However, we'll hit a problem with this. The @samp{@}} character also
closes the @samp{\end@{} command. Since we haven't told predictive mode
about @samp{\end@{}, every @samp{@}} that should close a @samp{\end@{}
command will instead be interpreted as the end of a @samp{\start@{}
command, probably resulting in lots of unmatched @samp{@}} characters
creating switch-dictionary regions stretching to the beginning of the
buffer. Clearly, we need something more along the lines of:

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" '(priority . 2)))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

@noindent
We still haven't solved the problem though. The @samp{@}} character
doesn't only close @samp{\begin@{} and @samp{\end@{} commands in
La@TeX{}. @emph{All} arguments to La@TeX{} commands are surrounded by
@samp{@{} and @samp{@}}. We could add all the commands that take
arguments, but we don't really want to switch dictionaries for those
other commands (at least in this example). All we want to do is prevent
predictive mode incorrectly pairing the @samp{@}} characters used for
other commands. Instead, we can just add @samp{@{} to the list:

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "@{" '(priority . 2))
  ('start "\\begin@{" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" '(priority . 2)))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

@noindent
Notice how the @code{@{} and @code{@}} regexps do not have a dictionary
associated with them, so any switch-dictionary regions they create will
not have any effect, other than making sure predictive mode correctly
pairs all @samp{@{} and @samp{@}} characters. We've made one
mistake though: by putting the @code{@{} regexp at the beginning of the
list, it will take priority over any other regexp in the list that could
match the same text. And since @code{@{} will match whenever
@code{\begin@{} or @code{\end@{} matches, predictive mode will never
create a @code{dict-latex-env} region! The @code{@{} regexp must appear
@emph{after} the @code{\begin@{} and @code{\end@{} regexps, to ensure it
is only used if neither of them match (it doesn't matter whether it
appears before or after the @code{@{} regexp, since the latter will
never match the same text and neither set dictionaries):

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" ('dict . 'dict-latex-env) ('priority . 2))
  ('start "@{" '(priority . 2))
  ('end "@}" '(priority . 2)))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

There is one last issue. A literal @samp{@{} or @samp{@}} character can
be included in a La@TeX{} document by escaping it with @samp{\}:
@samp{\@{} and @samp{\@}}. In this situation, the characters do not
match anything and should not be treated as delimiters. We can modify
the @code{@{} and @code{@}} regexps to exclude these cases:

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" ('dict . 'dict-latex-env) ('priority . 2))
  ('start "\\([^\\]\\|^\\)@{" '(priority . 2))
  ('end "\\([^\\]\\|^\\)@}" '(priority . 2)))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

@noindent
The complicated-looking regexps will only match @samp{@{} and @samp{@}}
characters if they are @emph{not} preceded by a @samp{\} character
(@pxref{Regular Expressions, , , elisp, GNU Emacs Lisp Reference
Manual}).

However, when it does match, the @samp{@}} regexp will now match an
additional character before the @samp{@}}, causing the switch-dictionary
region to end one character early. (The @samp{@{} regexp will also match
one additional character before the @samp{@{}, but since the beginning
of the switch-dictionary region starts from the @emph{end} of the
@code{start} delimiter, this poses no problem.) We need to group the
part of the regexp that should define the delimiter, i.e. the @code{@}},
by surrounding it with @code{\(} and @code{\)}, and put the regexp in
the @code{car} of a cons cell whose @code{cdr} specifies the new
subgroup (i.e. the 2nd subgroup, since the regexp already included a
group for other reasons). Our finished regexp list looks like this:

@lisp
(('line "%" ('dict . 'predictive-main-dict) ('priority . 4)
            ('exclusive . t))
 ('self "\\$" ('dict . 'dict-latex-math) ('priority . 3))
 ('stack
  ('start "\\begin@{" ('dict . 'dict-latex-env) ('priority . 2))
  ('end "@}" ('dict . 'dict-latex-env) ('priority . 2))
  ('start "\\([^\\]\\|^\\)@{" '(priority . 2))
  ('end ("\\([^\\]\\|^\\)\\(@}\\)" . 2) '(priority . 2)))
 ('stack
  ('start "\\begin@{equation@}" ('dict . 'dict-latex-math) ('priority . 1))
  ('end "\\end@{equation@}" ('dict . 'dict-latex-math) ('priority . 1)))
 ('word ("\\\\\\([[:alpha:]]*?\\)\\([^[:alpha:]]\\|$\\)" . 1)
        ('dict . 'dict-latex)))
@end lisp

With these regexps, predictive mode will switch to a dictionary of
La@TeX{} commands whenever you type a @samp{\} character. It will switch
to a dictionary of maths commands when you are typing text within an
@samp{equation} environment, or text surrounded by @samp{$}
delimiters. It will ignore La@TeX{} markup within comments between
@samp{%} and the end of the line. It will switch to a dictionary of
La@TeX{} environment names when typing a @samp{\begin} or @samp{\end}
command. And it will correctly take account of @samp{@{} and @samp{@}}
characters from other commands. Not bad for a bundle of brackets!



@node Displaying Active Dictionaries in the Mode Line
@subsection Displaying Active Dictionaries in the Mode Line
@cindex dictionary switching, active dictionary
@cindex dictionary switching, mode line
@cindex displaying active dictionary
@cindex mode line, active dictionary
@vindex predictive-which-dict

Predictive mode can display the name of the dictionary or dictionaries
that are active at the point. The name appears in the mode line, after
the predictive minor mode indicator. It is enabled along with predictive
mode when the @env{predictive-which-dict} variable is non-nil (disabled
by default), and can be toggled on and off with the
@command{predictive-which-dict-mode} command.

This feature is particularly useful for debugging regexps in when trying
to set up switch-dictionary regions.



@node Low-Level Details
@subsection Low-Level Details
@cindex dictionary switching, low-level details

Anyone familiar with Emacs lisp may recognize the @code{priority}
property that can be associated with a regexp as an overlay property. In
fact, the switch-dictionary regions in predictive mode are implemented
using overlays. The properties are just passed on to the
overlay. Although the @code{priority} property is the most useful
standard property, any other overlay property can be specified too
(@pxref{Overlay Properties, , , elisp, GNU Emacs Lisp Reference
Manual}). Clever use of the @code{modification-hooks} property, for
example, could produce some interesting effects, or the @code{face}
property could help when debugging your regexps@enddots{}




@node Dictionary Learning
@section Dictionary Learning
@cindex dictionaries, learning
@cindex learning

The better the weights in a dictionary match the frequency with which
you use words, the more useful predictive mode will be. Some of the
standard dictionaries already include word weights, which match average
word frequencies taken from a large sample of texts. Some don't include
any word weights. In any case, your personal word usage might be very
different from the average.

Ideally, the weights in a dictionary should match your personal style of
writing. In fact, since your writing style might change significantly
depending on whether you're writing, say, a scientific article or an
email, it may even be worth having different dictionaries for different
circumstances.

The easiest way to teach a dictionary about your writing style is to
supply it with samples of your writing, and have it learn the word
weights from them. Predictive mode provides two ways to do this:
learning from existing files, and automatic learning as you type.

@menu
* Learning from Buffers and Files::  
* Automatic Learning::          
@end menu


@node Learning from Buffers and Files
@subsection Learning from Buffers and Files
@cindex learning from buffers
@cindex learning from files
@cindex dictionaries, learning from buffers
@cindex dictionaries, learning from files

Predictive mode can learn word weights from existing text. The following
commands can be used to do this. Note that they will not add new words
to a dictionary; they only update weight of word that are already in the
dictionary. The learning commands can use the information provided by
switch-dictionary regions to decide which dictionary a word belongs
to.

Note that all the learning commands (even the ``fast'' ones!) can take a
long time to run.

@ftable @command
@item predictive-learn-from-buffer
Learns weights for words in a dictionary from text in a buffer. By
default, learns word weights for all dictionaries used by the current
buffer when predictive mode is enabled (@pxref{Loading and Saving
Dictionaries}). Each occurence of a word increments its weight in the
dictionary. By default, only occurences that occur in a region where the
dictionary is active are taken into account (@pxref{Defining
Regions}). This can be overridden by supplying a prefix argument, in
which case all occurences are taken into account.

@item predictive-learn-from-file
Like @command{predictive-learn-from-buffer}, but learns from a file
instead of a buffer.

@item predictive-fast-learn-from-buffer
Similar to @command{predictive-learn-from-buffer}. It runs faster for
large dictionaries, at the expense of missing some words. Specifically,
only words consisting entirely of word- or symbol-constituent characters
(according to the buffer's syntax table) will be taken into account.

@item predictive-fast-learn-from-file
Like @command{predictive-fast-learn-from-buffer}, but learns from a file
instead of a buffer.
@end ftable


@node Automatic Learning
@subsection Automatic Learning
@cindex automatic learning
@cindex learning, automatic
@cindex dictionary, automatic learn

Predictive mode can automatically learn which words you use most often
as you type, in order to make better predictions. This feature is
especially useful when you first start using a dictionary, to adapt it
to your writing style. Once a dictionary has `learned' and is making
good predictions, it can be turned off to fix the order in which
completions are offered (@pxref{What is predictive completion?}).

@noindent
The following variables control automatic learning:

@vtable @env
@item predictive-auto-learn
Controls automatic word frequency learning. When non-nil, the weight for
a word in is incremented each time it is accepted as a completion,
making the word more likely to be offered higher up the list of
completions in the future. Words that are not already in the dictionary
are ignored unless @env{predictive-auto-add-to-dict} is set. Auto learn
is disabled by default.

@item predictive-auto-add-to-dict
Controls automatic adding of new words to dictionaries. If nil (the
default), words are never automatically added to a dictionary. If
@code{t}, new words are automatically added to the active dictionary.

If set to a dictionary name, new words are automatically added to that
dictionary instead of the active one. If set to the special symbol
@code{buffer}, new words are automatically added to the word list at the
end of the buffer (@pxref{Buffer Dictionaries}).

@item predictive-add-to-dict-ask
If non-nil, predictive mode will ask for confirmation before
automatically adding any word to a dictionary. Enabled by default. This
has no effect unless @env{predictive-auto-add-to-dict} is also set.

@item predictive-use-auto-learn-cache
If non-nil (the default), auto-learned and auto-added words are cached,
and only actually added to the dictionary when Emacs has been idle for
@env{predictive-flush-auto-learn-delay} seconds (it has no effect unless
at least one of @env{predictive-auto-learn} or
@env{predictive-auto-add-to-dict} is also set). This avoids small but
sometimes noticeable delays when typing. New words or word weights will
not be taken into account until the cache is fully flushed.
@end vtable

Note that if @env{predictive-main-dict} contains a list of dictionary
names (@pxref{Basic Dictionary Usage}), an automatically learned or
added word may not end up where you want it. The weight of a word is
incremented in the first dictionary it is found in, and words are added
to the first dictionary in the list (assuming
@env{predictive-auto-add-to-dict} is set to @code{t}). The buffer
dictionary has lowest priority (@pxref{Buffer Dictionaries}). It is best
to ensure that dictionaries in the list, and the buffer dictionary, do
not duplicate any words.
@vindex predictive-main-dict
@cindex buffer dictionary
@cindex dictionary, buffer



@node Buffer Dictionaries
@section Buffer Dictionaries
@cindex buffer dictionary
@cindex dictionary, buffer
@vindex predictive-buffer-dict

One special dictionary is not saved in a file, but is recreated and
stored in the buffer-local @env{predictive-buffer-dict} variable
whenever a file is loaded into a buffer. The buffer dictionary is
populated from a word list at the end of the buffer.

The start of this word list is indicated by the text
@samp{predictive-mode local words:}. The entries start on the following
line and take the same format as files used to populate a normal
dictionary: words delimited by @samp{""}, optional weights separated
from the words by whitespace. @xref{Creating Dictionaries}. Since
characters before the first quote @samp{"} are ignored, the words can be
commented out with whatever comment character is appropriate. Usually,
you will not need to create the word list manually, since words can be
inserted into it automatically (@pxref{Automatic Learning}) or using the
@command{predictive-add-to-buffer-dict} command:
@findex predictive-add-to-buffer-dict

@ftable @command
@item predictive-add-to-buffer-dict
Adds a word to the word list at the end of the current buffer, and to
the buffer-local dictionary. The word is read from the mini-buffer and
its weight can optionally be specified by a prefix argument. If the word
is already there, its weight is incremented.
@end ftable

Buffer dictionaries are particularly useful when using programming
languages. A general dictionary will only contain the functions and
keywords defined in the language itself. The buffer dictionary can be
used to store variable and function names specific to one file.





@node Character Syntax and Key Bindings
@chapter Character Syntax and Key Bindings
@cindex characters
@cindex syntax
@cindex key bindings
@cindex bindings

Predictive mode significantly changes what happens when normal,
printable characters are typed. Different characters cause different
behaviour. For example, letter characters will usually be added to the
current word, updating the completions, whereas punctuation characters
end the completion process.

This chapter describes the mechanisms that determine the behaviour of
different characters, and how to customize them.

@menu
* Keymaps and Key Bindings::    
* Syntax::                      
* Functions for Binding to Characters::  
@end menu



@node Keymaps and Key Bindings
@section Keymaps and Key Bindings
@cindex keymaps and key bindings
@cindex key bindings
@cindex keymaps
@cindex bindings

@noindent
The following keymaps are defined by predictive mode:

@vtable @env
@item predictive-map
Main keymap, enabled whenever predictive mode is.

@item predictive-completing-map
Keymap used when in the process of completing a word.

@item predictive-offer-completions-map
Keymap used when completions are available to select from the
completions list. Constructed from
@env{predictive-offer-completions-keylist}. Setting this directly has no
effect. Set @env{predictive-offer-completions-keylist} instead.

@item predictive-offer-completions-keylist
List of characters to use for selecting completions from the completions
list. Default is numerical characters 0 to 9. @xref{Offering a List of
Completions}.
@end vtable

@findex predictive-self-insert.
@vindex predictive-syntax-alist
@vindex predictive-override-syntax-alist

The various keymaps define key bindings for different situations that
arise in predictive mode. The main @env{predictive-map} keymap is
enabled whenever predictive mode is enabled. By default, this keymap
binds all printable characters to the @command{predictive-self-insert}
function (@pxref{Functions for Binding to Characters}).

Note: if you find yourself thinking of re-binding printable characters
in @env{predictive-map} to something other than
@command{predictive-self-insert}, don't! (at least not until you've read
on a bit). What you probably want to change are the
@env{predictive-syntax-alist} and @env{predictive-override-syntax-alist}
variables. @xref{Syntax}.

The @env{predictive-completing-map} is only enabled when a completion is
in progress, and is used to bind key combinations to completion
functions that are only relevant in that situation (@pxref{Basic
Completion Commands}).

The final keymap, @env{predictive-offer-completions-map}, is enabled
when the completions are available to select from the completion
list. It is constructed automatically from the characters listed in
@env{predictive-offer-completions-keylist}, and binds all those
characters to @command{predictive-select-completion} (@pxref{Functions
for Binding to Characters}). It should @emph{not} be set directly; you
may get strange results if the keymap and key list do not correspond!
@findex predictive-select-completion

If the keymaps are not defined when predictive mode is first loaded (for
instance by a @code{(require 'predictive)} line in your @file{.emacs}
file), it creates the default keymaps and loads them into
Emacs. Therefore, to customize predictive mode key bindings, you must
re-define the keymap variables @emph{before} loading predictive mode
(e.g. before the @code{(require 'predictive)} line).
@cindex .emacs file
@cindex startup file
@cindex configuration file



@node Syntax
@section Syntax
@cindex syntax
@cindex characters, syntax

@vtable @env
@item predictive-syntax-alist
Alist associating character syntax descriptors with completion
functions. Used by the @command{predictive-self-insert} function to
decide what to do based on a typed character's syntax.

@item predictive-override-syntax-alist
Alist associating characters with completion functions. Overrides the
default function for a typed character's syntax. Used by
@command{predictive-self-insert}.

@item predictive-dict-alist
Alist associating a character with a dictionary to switch to.
@end vtable

When a character is typed, predictive mode decides what to do based on
that character's syntax, as defined by the current syntax table
(@pxref{Syntax, , , emacs, GNU Emacs Manual}). All printable characters
are bound by default to the function @command{predictive-self-insert}
(@pxref{Functions for Binding to Characters}), which looks up a
character's syntax descriptor in @env{predictive-syntax-alist}, and runs
the corresponding function.
@findex predictive-self-insert

By default, all word-constituent characters (syntax descriptor @code{w})
are bound to @command{predictive-insert-and-complete}, all white-space
and punctuation characters (descriptors @code{SPACE} and @code{.}) are
bound to @command{predictive-accept-and-insert}, and anything else is
bound to @command{predictive-abandon-and-insert}. @xref{Functions for
Binding to Characters}.
@findex predictive-insert-and-complete
@findex predictive-accept-and-insert
@findex predictive-abandon-and-insert

Occasionally, the syntax-derived behaviour needs to be overridden for
certain characters. The @env{predictive-override-syntax-alist}
associates characters with functions, and takes precedence over
@env{predictive-syntax-alist}.



@node Functions for Binding to Characters
@section Functions for Binding to Characters
@cindex functions for binding to characters
@vindex predictive-syntax-alist
@vindex predictive-override-syntax-alist

All predictive mode functions with @samp{insert} in their names insert
the last input event into the buffer, in addition to carrying out
whatever completion-related task they perform (@pxref{Basic Completion
Commands}). Therefore unless you know what you are doing, they should
probably only be bound to printable characters, or used in the
@env{predictive-syntax-alist} and @env{predictive-override-syntax-alist}
variables (@pxref{Syntax}).

@ftable @command
@item predictive-self-insert
Decide what completion function to execute by looking up the character's
syntax in @env{predictive-syntax-alist}. The syntax-derived function can
be overridden for individual characters by
@env{predictive-override-syntax-alist}.

@item predictive-insert-and-complete
Insert the last input event, which should be a printable character, and
complete the resulting, longer string.

@item predictive-accept-and-insert
Accept the current completion, and insert the last input invent, which
should be a single printable character.

@item predictive-abandon-and-insert
Abandon the current completion, and insert the last input invent, which
should be a single printable character.

@item predictive-scoot-or-accept-and-insert
If the point is not already at the end of the current completion, insert
the characters from the current completion and look for completions of
the resulting, longer string. If point is already at the end, accept the
completion and insert the last input event, which should be a printable
character.

@item predictive-select-completion
Select a completion to insert from the completion list. Automatically
bound to the characters listed in
@env{predictive-offer-completions-keylist} when the
@env{predictive-offer-completions-map} keymap is
constructed. @xref{Keymaps and Key Bindings}, and @ref{Offering a List
of Completions}.
@vindex predictive-offer-completions-keylist
@vindex predictive-offer-completions-map
@end ftable





@node Working with Major Modes
@chapter Working with Major Modes
@cindex working with major modes
@cindex major modes

The many features of predictive mode allow you to set things up
appropriately for whatever language you are typing, whether it be plain
text, markup languages such as HTML or La@TeX{}, programming languages
such as C or Lisp, etc. Predictive mode will work happily alongside the
appropriate major-mode. However, since each language requires different
things of predictive completion, you may find yourself changing a large
number of settings when switching major modes.

To facilitate using predictive completion alongside different
major-modes, predictive mode can run a setup function determined by the
current major-mode whenever it is switched on in a buffer. Of course,
you can also use major mode hooks, but hooks are less convenient if you
don't want to always switch on predictive mode in that major mode, or if
you want to switch it on and off whilst within the mode.
@cindex setup function
@cindex major mode hooks

@vtable @env
@item predictive-major-mode-alist
Alist associating a major-mode symbol with a function. The alist is
checked whenever predictive mode is switched on in a buffer using the
@command{predictive-mode} or @command{turn-on-predictive-mode} commands
(@pxref{Basic Completion Commands}), and if the buffer's major-mode
matches one in the alist, the associated function is called. This makes
it easier to customize predictive mode for different major modes.
@findex predictive-mode
@findex turn-on-predictive-mode
@end vtable

Since the setup function is determined by the current major-mode,
predictive mode should be switched on @emph{after} switching to the
appropriate major-mode. If you always want to use predictive mode with a
particular major-mode, the easiest way to do this is to add the
@command{predictive-mode} command to the major-mode hook in your
@file{.emacs} file, using a line something like this:
@cindex .emacs file
@cindex startup file
@cindex configuration file
@lisp
(add-hook '@var{major-mode}-hook 'turn-on-predictive-mode)
@end lisp

The predictive package itself contains one setup function for typing
normal English text, @command{predictive-setup-english}, which mostly
reproduces the default settings of most variables and customization
options. It also contains setup functions for La@TeX{}
(@command{predictive-setup-latex}), AMS La@TeX{}
(@command{predictive-setup-ams-latex}), HTML
(@command{predictive-setup-html}), and Fortran 90/95
(@command{predictive-setup-f90})@footnote{An ecclectic mix, which
reflects the things I use emacs for most often, and perhaps also the
fact that predictive completion mode is somewhat better suited to markup
languages than programming languages.}. More contributions are always
welcome! You must ensure that the dictionaries these setup functions
require (which are also included in the package, @pxref{Obtaining and
Installing}) can be found in your @env{load-path}.

Since many settings are down to personal preference, the setup functions
may not do precisely what you want, but if nothing else they provide
examples to base your own on.




@node Bugs and Future Improvements
@chapter Bugs and Future Improvements
@cindex bugs and future improvements
@cindex reporting bugs
@cindex bugs, reporting
@cindex feature requests
@cindex features, requesting

The predictive completion package has been tested on Emacs versions 21.3
and the multi-tty CVS branch, and is known to work reasonably well. It
has not been tested under older versions, or under any version of
X-Emacs.

Report bugs and feature requests to
@email{toby-predictive@@dr-qubit.org}. Even reports of which versions of
Emacs it runs under are useful at this stage (though check the web-site
@uref{http://www.dr-qubit.org/predictive.html} first to make sure your
version is not already listed).

However, if you're reporting a bug with the dictionary switching
features, and you've using your own regular expressions (rather than
using a setup function included in the package), please carefully
re-read the dictionary switching section of this manual
(@pxref{Automatic Dictionary Switching}, and especially the
@ref{Dictionary Switching Example}), make absolutely sure that the bug
isn't with your regexps rather than predictive mode, count to ten, check
your regexps again, stand on your head and count to ten again, and only
then report the bug (photographic evidence of these acrobatic antics
will give your bug report higher priority).

@menu
* Known Bugs::                  
* Future Improvements::         
@end menu



@node Known Bugs
@section Known Bugs
@cindex known bugs
@cindex bugs, known

@noindent
Known bugs (in no particular order):

@enumerate
@item
No @command{predictive-remove-from-dict} command exists to remove a word
from a dictionary. However, it it unlikely ever to exist unless there is
huge demand (because removing entries from a ternary search tree is
frought with difficulties). The quick-and-dirty work-around at the
moment is to reduce the word's weight using
@command{predictive-add-to-dict} with a large negative weight, so that
it is unlikely to show up as a likely completion. The better work-around
is to dump the dictionary to a text file using
@command{predictive-dump-words-to-file}, remove the offending word, and
recreate the dictionary.
@end enumerate



@node Future Improvements
@section Future Improvements
@cindex feature requests
@cindex future improvements

@noindent
Possible future improvements (in no particular order):

@enumerate
@item
Predictive mode should probably not find completions as you type if both
dynamic completion and the completion list are disabled. It might as
well just wait until asked, instead of wasting processor cycles.

@item
More dictionaries and setup functions. (This one will probably be here
for ever, since new major modes are probably being created faster than
predictive mode setup functions!)

@item
The switch-dictionary regions could be generalized to allow
region-specific values for all predictive mode configuration variables,
not just the active dictionary, though there doesn't seem to be much use
for this.

@item
A @code{flat} regexp class is missing, i.e. regions that start at a
@code{start} delimiter and ignore any further @code{start} delimiters
until the first following @code{end} delimiter (like block comments in
c++). This just requires adding a new class to the @dfn{auto-overlays}
package.

@item
The @command{auto-overlay-init} command takes a long time to create all
the overlays in even medium-sized buffers. There's not much one can do
about this the first time it's run, but the overlays could be saved in
an auxilliary file when killing the buffer or Emacs, and reloaded from
there to speed up subsequent invocations.
@end enumerate





@node Credits
@chapter Credits
@cindex credits

Much inspiration for the Emacs predictive completion package came from a
similar package written for the @dfn{nedit} editor by Christian
Merkwirth.
@c (@uref{http://www.physik3.gwdg.de/~cmerk/prog/nedit/index.html})
Most significantly, it provided the clue that ternary search trees are
the best structure to use for the dictionaries.

Ternary search trees are described in a very readable article by Jon
Bentley and Robert Sedgewick in Dr. Dobb's Journal, among other
places. The article can be found via
@uref{http://www.ddj.com/articles/1998/9804/}.

Finally, the English dictionary supplied with the predictive completion
package was based on the British National Corpus frequency tables,
available from
@uref{http://www.itri.brighton.ac.uk/~Adam.Kilgarriff/bnc-readme.html}.





@node Command Index
@appendix Command Index
@printindex fn


@node Variable Index
@appendix Variable Index
@printindex vr


@node Concept Index
@appendix Concept Index
@printindex cp





@node Copying this Manual
@appendix Copying this Manual

@menu
* GNU Free Documentation License::
@end menu

@include fdl.texi




@bye

@c  LocalWords:  Regexps regexps maths
